        -:    0:Source:aria.c
        -:    0:Graph:./main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * ANSI-C code for ARIA version 1.0
        -:    5: *
        -:    6: * Reference code for ARIA
        -:    7: *
        -:    8: * 2005. 01. 17.
        -:    9: * 
        -:   10: * Note:
        -:   11: *    - Now we use the following interface:
        -:   12: *      void Crypt(const Byte *plainText, int numberOfRounds, const Byte *roundKeys, Byte *cipherText);
        -:   13: *      int EncKeySetup(const Byte *masterKey, Byte *roundKeys, int keyBits);
        -:   14: *      int DecKeySetup(const Byte *masterKey, Byte *roundKeys, int keyBits);
        -:   15: *    - EncKeySetup() and DecKeySetup() return the number of rounds.
        -:   16: *
        -:   17: */
        -:   18:
        -:   19:#include <stdio.h>
        -:   20:#include <stdlib.h>
        -:   21:
        -:   22:typedef unsigned char Byte;
        -:   23:
        -:   24:const Byte S[4][256] = {
        -:   25:	// S-box type 1
        -:   26:{
        -:   27:  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        -:   28:  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        -:   29:  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        -:   30:  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        -:   31:  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        -:   32:  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        -:   33:  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        -:   34:  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        -:   35:  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        -:   36:  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        -:   37:  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        -:   38:  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        -:   39:  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        -:   40:  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        -:   41:  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        -:   42:  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16},
        -:   43:  // S-box type 2
        -:   44:{
        -:   45:  0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1,
        -:   46:  0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1,
        -:   47:  0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb,
        -:   48:  0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb,
        -:   49:  0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd,
        -:   50:  0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53,
        -:   51:  0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1,
        -:   52:  0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40,
        -:   53:  0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc,
        -:   54:  0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5,
        -:   55:  0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43,
        -:   56:  0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8,
        -:   57:  0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda,
        -:   58:  0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c,
        -:   59:  0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d,
        -:   60:  0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81},
        -:   61:  // inverse of S-box type 1
        -:   62:{
        -:   63:  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        -:   64:  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        -:   65:  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        -:   66:  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        -:   67:  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        -:   68:  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        -:   69:  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        -:   70:  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        -:   71:  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        -:   72:  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        -:   73:  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        -:   74:  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        -:   75:  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        -:   76:  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        -:   77:  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        -:   78:  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d},
        -:   79:  // inverse of S-box type 2
        -:   80:{
        -:   81:  0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62, 0x3c,
        -:   82:  0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20, 0xc4, 0x8d,
        -:   83:  0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4, 0x40, 0x1a, 0x4d,
        -:   84:  0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98, 0x0c, 0xf4, 0x9b, 0xed,
        -:   85:  0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06, 0xc3, 0x35, 0x0d, 0x01, 0x8b,
        -:   86:  0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e, 0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce,
        -:   87:  0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4, 0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9,
        -:   88:  0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19, 0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41,
        -:   89:  0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe, 0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a,
        -:   90:  0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7,
        -:   91:  0x84, 0xe9, 0xd2, 0xba, 0x5d, 0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc,
        -:   92:  0xeb, 0x6f, 0xd5, 0xf6, 0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5,
        -:   93:  0x91, 0x1f, 0x05, 0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45,
        -:   94:  0xb2, 0x0f, 0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d,
        -:   95:  0xf2, 0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3,
        -:   96:  0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac, 0x60}
        -:   97:};
        -:   98:// constants used in the round key generation
        -:   99:const Byte KRK[3][16] =
        -:  100:{
        -:  101:  {0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0}, 
        -:  102:  {0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0}, 
        -:  103:  {0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e}
        -:  104:};
        -:  105:
        -:  106:// Diffusion Layer
function DL called 0 returned 0% blocks executed 0%
    #####:  107:void DL (const Byte *i, Byte *o)
        -:  108:{
        -:  109:	Byte T;
        -:  110:  
    #####:  111:	T = i[ 3] ^ i[ 4] ^ i[ 9] ^ i[14];
    #####:  112:	o[ 0] = i[ 6] ^ i[ 8] ^ i[13] ^ T;
    #####:  113:	o[ 5] = i[ 1] ^ i[10] ^ i[15] ^ T;
    #####:  114:	o[11] = i[ 2] ^ i[ 7] ^ i[12] ^ T;
    #####:  115:	o[14] = i[ 0] ^ i[ 5] ^ i[11] ^ T;
    #####:  116:	T = i[ 2] ^ i[ 5] ^ i[ 8] ^ i[15];
    #####:  117:	o[ 1] = i[ 7] ^ i[ 9] ^ i[12] ^ T;
    #####:  118:	o[ 4] = i[ 0] ^ i[11] ^ i[14] ^ T;
    #####:  119:	o[10] = i[ 3] ^ i[ 6] ^ i[13] ^ T;
    #####:  120:	o[15] = i[ 1] ^ i[ 4] ^ i[10] ^ T;
    #####:  121:	T = i[ 1] ^ i[ 6] ^ i[11] ^ i[12];
    #####:  122:	o[ 2] = i[ 4] ^ i[10] ^ i[15] ^ T;
    #####:  123:	o[ 7] = i[ 3] ^ i[ 8] ^ i[13] ^ T;
    #####:  124:	o[ 9] = i[ 0] ^ i[ 5] ^ i[14] ^ T;
    #####:  125:	o[12] = i[ 2] ^ i[ 7] ^ i[ 9] ^ T;
    #####:  126:	T = i[ 0] ^ i[ 7] ^ i[10] ^ i[13];
    #####:  127:	o[ 3] = i[ 5] ^ i[11] ^ i[14] ^ T;
    #####:  128:	o[ 6] = i[ 2] ^ i[ 9] ^ i[12] ^ T;
    #####:  129:	o[ 8] = i[ 1] ^ i[ 4] ^ i[15] ^ T;
    #####:  130:	o[13] = i[ 3] ^ i[ 6] ^ i[ 8] ^ T;
    #####:  131:}
        -:  132:// Right-rotate 128 bit source string s by n bits and XOR it to target string t
function RotXOR called 0 returned 0% blocks executed 0%
    #####:  133:void RotXOR (const Byte *s, int n, Byte *t)
        -:  134:{
        -:  135:	int i, q;
        -:  136:  
    #####:  137:	q = n/8; n %= 8;
    #####:  138:	for (i = 0; i < 16; i++) {
branch  0 never executed
branch  1 never executed
    #####:  139:		t[(q+i) % 16] ^= (s[i] >> n);
    #####:  140:		if (n != 0) t[(q+i+1) % 16] ^= (s[i] << (8-n));
branch  0 never executed
branch  1 never executed
        -:  141:	}
    #####:  142:}
        -:  143:
        -:  144:void printBlock (Byte *b);
        -:  145:
        -:  146:// Encryption round key generation rountine
        -:  147:// w0 : master key, e : encryption round keys
function EncKeySetup called 0 returned 0% blocks executed 0%
    #####:  148:int EncKeySetup (const Byte *w0, Byte *e, int keyBits)
        -:  149:{
    #####:  150:	int  i, R = (keyBits + 256) / 32, q;
        -:  151:	Byte t[16], w1[16], w2[16], w3[16];
        -:  152:  
    #####:  153:	q = (keyBits - 128) / 64;
    #####:  154:	for (i = 0; i < 16; i++) t[i] = S[     i  % 4][KRK[q][i   ] ^ w0[i]];
branch  0 never executed
branch  1 never executed
    #####:  155:	DL (t, w1);
call    0 never executed
    #####:  156:	if (R==14)
branch  0 never executed
branch  1 never executed
    #####:  157:		for (i = 0; i <  8; i++) w1[i] ^= w0[16+i];
branch  0 never executed
branch  1 never executed
    #####:  158:	else if (R==16)
branch  0 never executed
branch  1 never executed
    #####:  159:		for (i = 0; i < 16; i++) w1[i] ^= w0[16+i];
branch  0 never executed
branch  1 never executed
        -:  160:  
    #####:  161:	q = (q==2)? 0 : (q+1);
branch  0 never executed
branch  1 never executed
    #####:  162:	for (i = 0; i < 16; i++) t[i] = S[(2 + i) % 4][KRK[q][i] ^ w1[i]];
branch  0 never executed
branch  1 never executed
    #####:  163:	DL (t, w2);
call    0 never executed
    #####:  164:	for (i = 0; i < 16; i++) w2[i] ^= w0[i];
branch  0 never executed
branch  1 never executed
        -:  165:  
    #####:  166:	q = (q==2)? 0 : (q+1);
branch  0 never executed
branch  1 never executed
    #####:  167:	for (i = 0; i < 16; i++) t[i] = S[     i  % 4][KRK[q][i] ^ w2[i]];
branch  0 never executed
branch  1 never executed
    #####:  168:	DL (t, w3);
call    0 never executed
    #####:  169:	for (i = 0; i < 16; i++) w3[i] ^= w1[i];
branch  0 never executed
branch  1 never executed
        -:  170:  
    #####:  171:	for (i = 0; i < 16*(R+1); i++) e[i] = 0;
branch  0 never executed
branch  1 never executed
        -:  172:  
    #####:  173:	RotXOR (w0, 0, e      ); RotXOR (w1,  19, e      );
call    0 never executed
call    1 never executed
    #####:  174:	RotXOR (w1, 0, e +  16); RotXOR (w2,  19, e +  16);
call    0 never executed
call    1 never executed
    #####:  175:	RotXOR (w2, 0, e +  32); RotXOR (w3,  19, e +  32);
call    0 never executed
call    1 never executed
    #####:  176:	RotXOR (w3, 0, e +  48); RotXOR (w0,  19, e +  48);
call    0 never executed
call    1 never executed
    #####:  177:	RotXOR (w0, 0, e +  64); RotXOR (w1,  31, e +  64);
call    0 never executed
call    1 never executed
    #####:  178:	RotXOR (w1, 0, e +  80); RotXOR (w2,  31, e +  80);
call    0 never executed
call    1 never executed
    #####:  179:	RotXOR (w2, 0, e +  96); RotXOR (w3,  31, e +  96);
call    0 never executed
call    1 never executed
    #####:  180:	RotXOR (w3, 0, e + 112); RotXOR (w0,  31, e + 112);
call    0 never executed
call    1 never executed
    #####:  181:	RotXOR (w0, 0, e + 128); RotXOR (w1,  67, e + 128);
call    0 never executed
call    1 never executed
    #####:  182:	RotXOR (w1, 0, e + 144); RotXOR (w2,  67, e + 144);
call    0 never executed
call    1 never executed
    #####:  183:	RotXOR (w2, 0, e + 160); RotXOR (w3,  67, e + 160);
call    0 never executed
call    1 never executed
    #####:  184:	RotXOR (w3, 0, e + 176); RotXOR (w0,  67, e + 176);
call    0 never executed
call    1 never executed
    #####:  185:	RotXOR (w0, 0, e + 192); RotXOR (w1,  97, e + 192);
call    0 never executed
call    1 never executed
    #####:  186:	if (R > 12) {
branch  0 never executed
branch  1 never executed
    #####:  187:		RotXOR (w1, 0, e + 208); RotXOR (w2,  97, e + 208);
call    0 never executed
call    1 never executed
    #####:  188:		RotXOR (w2, 0, e + 224); RotXOR (w3,  97, e + 224);
call    0 never executed
call    1 never executed
        -:  189:	}
    #####:  190:	if (R > 14) {
branch  0 never executed
branch  1 never executed
    #####:  191:		RotXOR (w3, 0, e + 240); RotXOR (w0,  97, e + 240);
call    0 never executed
call    1 never executed
    #####:  192:		RotXOR (w0, 0, e + 256); RotXOR (w1, 109, e + 256);
call    0 never executed
call    1 never executed
        -:  193:	}
    #####:  194:	return R;
        -:  195:}
        -:  196:// Decryption round key generation rountine
        -:  197:// w0 : maskter key, d : decryption round keys
function DecKeySetup called 0 returned 0% blocks executed 0%
    #####:  198:int DecKeySetup (const Byte *w0, Byte *d, int keyBits)
        -:  199:{
        -:  200:	int  i, j, R;
        -:  201:	Byte t[16];
        -:  202:  
    #####:  203:	R=EncKeySetup(w0, d, keyBits);
call    0 never executed
    #####:  204:	for (j = 0; j < 16; j++){
branch  0 never executed
branch  1 never executed
    #####:  205:		t[j] = d[j];
    #####:  206:		d[j] = d[16*R + j];
    #####:  207:		d[16*R + j] = t[j];
        -:  208:	}
    #####:  209:	for (i = 1; i <= R/2; i++){
branch  0 never executed
branch  1 never executed
    #####:  210:		DL (d + i*16, t);
call    0 never executed
    #####:  211:		DL (d + (R-i)*16, d + i*16);
call    0 never executed
    #####:  212:		for (j = 0; j < 16; j++) d[(R-i)*16 + j] = t[j];
branch  0 never executed
branch  1 never executed
        -:  213:	}
    #####:  214:	return R;
        -:  215:}
        -:  216:// Encryption and decryption rountine
        -:  217:// p: plain text, e: round keys, c: ciphertext
function Crypt called 0 returned 0% blocks executed 0%
    #####:  218:void Crypt (const Byte *p, int R, const Byte *e, Byte *c)
        -:  219:{
        -:  220:	int i, j;
        -:  221:	Byte t[16];
        -:  222:  
    #####:  223:	for (j = 0; j < 16; j++) c[j] = p[j];
branch  0 never executed
branch  1 never executed
    #####:  224:	for (i = 0; i < R/2; i++)
branch  0 never executed
branch  1 never executed
        -:  225:	{
    #####:  226:		for (j = 0; j < 16; j++) t[j] = S[     j  % 4][e[j] ^ c[j]];
branch  0 never executed
branch  1 never executed
    #####:  227:		DL(t, c); e += 16;
call    0 never executed
    #####:  228:		for (j = 0; j < 16; j++) t[j] = S[(2 + j) % 4][e[j] ^ c[j]];
branch  0 never executed
branch  1 never executed
    #####:  229:		DL(t, c); e += 16;
call    0 never executed
        -:  230:	}
    #####:  231:	DL(c, t);
call    0 never executed
    #####:  232:	for (j = 0; j < 16; j++) c[j] = e[j] ^ t[j];
branch  0 never executed
branch  1 never executed
    #####:  233:}
        -:  234:
function printBlockOfLength called 0 returned 0% blocks executed 0%
    #####:  235:void printBlockOfLength (Byte *b, int len)
        -:  236:{
        -:  237:	int i;
        -:  238:  
    #####:  239:	for (i=0; i<len; i++, b++) {
branch  0 never executed
branch  1 never executed
    #####:  240:		printf("%02x", *b);
call    0 never executed
    #####:  241:		if (i%4==3 && i<len-1) printf(" ");
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
        -:  242:	}
    #####:  243:}
        -:  244:
function printBlock called 0 returned 0% blocks executed 0%
    #####:  245:void printBlock(Byte *b)
        -:  246:{
    #####:  247:  printBlockOfLength(b, 16);
call    0 never executed
    #####:  248:}
        -:  249:
function ARIA called 0 returned 0% blocks executed 0%
    #####:  250:char ARIA (Byte *p)
        -:  251:{
        -:  252:	Byte rk[16*17], c[16], mk[32];
        -:  253:	int i;
        -:  254:
    #####:  255:	for (i=0; i<16; i++)
branch  0 never executed
branch  1 never executed
    #####:  256:		mk[i]=i*0x11;
    #####:  257:	for (i=16; i<24; i++)
branch  0 never executed
branch  1 never executed
    #####:  258:		mk[i]=(i-16)*0x11;
        -:  259:  
    #####:  260:	Crypt(p, EncKeySetup(mk, rk, 192), rk, c);
call    0 never executed
call    1 never executed
        -:  261:
    #####:  262:	return *p;
        -:  263:}
        -:  264:
        -:  265:
