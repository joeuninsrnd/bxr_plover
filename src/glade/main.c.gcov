        -:    0:Source:main.c
        -:    0:Graph:./main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "plover.h"
        -:    2:#include <unistd.h>
        -:    3:#include <assert.h>
        -:    4:#include <dirent.h>
        -:    5:#include <sys/types.h>
        -:    6:#include <sys/stat.h>
        -:    7:#include <regex.h>
        -:    8:#include "iniparser.h"
        -:    9:#include "iniparser.c"
        -:   10:#include "dictionary.h"
        -:   11:#include "dictionary.c"
        -:   12:
        -:   13:#define	MAX_ERROR_MSG	0x1000
        -:   14:#define	ERASER_SIZE	512		//1k
        -:   15:#define	ERASER_ENC_SIZE	896		//1k
        -:   16:
        -:   17:int x,y,z; //지울거
        -:   18:int nomatch;				// regex //
        -:   19:const int n_matches = 200;		// "N_matches" is the maximum number of matches allowed. //
        -:   20:
        -:   21:static gchar *dpath;			// default 경로 //
        -:   22:static gchar *path;			// 검사 파일경로 //
        -:   23:static gchar *name;			// 등록 유저이름 //
        -:   24:static gchar *job;			// 등록 직급이름 //
        -:   25:static gchar *vs_dept;			// 등록 부서이름 //
        -:   26:
        -:   27:static int	chk_fcnt = -1;		// 검출파일 총 개수 0부터 1개//
        -:   28:static char	chk_fname[100];		// 정규식돌고있는 파일이름 //
        -:   29:static char	chk_uuid[40];		// INI UUID 확인 //
        -:   30:static char	set_uuid[40];		// UUID 저장 //
        -:   31:static int	chk_df = 0;		// chk data flag //
        -:   32:static const char	*chk_ver;	// chk version //
        -:   33:static gchar	*fname;
        -:   34:static GtkTreeViewColumn	*dcol;
        -:   35:static GtkCellRenderer		*drenderer;
        -:   36:
        -:   37:
        -:   38:GtkWidget		*main_window,
        -:   39:			*m_userinfo_label,
        -:   40:			*m_verion_label,
        -:   41:			*enrollment_window,
        -:   42:			*e_jobtitle_cbxtext,
        -:   43:			*e_verion_label,
        -:   44:			*detect_window,
        -:   45:			*department_window,
        -:   46:			*d_progressbar_status,
        -:   47:			*d_progressbar,
        -:   48:			*setting_window,
        -:   49:			*window;
        -:   50:						
        -:   51:GtkEntry		*e_name_entry,
        -:   52:			*e_jobtitle_entry,
        -:   53:			*e_department_entry,
        -:   54:			*d_detect_entry,
        -:   55:			*s_detect_entry,
        -:   56:			*s_ip_entry,
        -:   57:			*s_port_entry;
        -:   58:
        -:   59:GtkScrolledWindow	*d_scrolledwindow,
        -:   60:			*dept_scrolledwindow;
        -:   61:
        -:   62:GtkWidget 		*filechooserdialog;
        -:   63:
        -:   64:GtkWidget		 *d_view;
        -:   65:
        -:   66:GtkTreeStore		*dtreestore;
        -:   67:GtkTreeIter		diter;
        -:   68:
        -:   69:GtkBuilder		*builder;
        -:   70:
        -:   71:// Create IniFile //
function func_CreateIni called 0 returned 0% blocks executed 0%
    #####:   72:void func_CreateIni(void)
        -:   73:{
        -:   74:    FILE    *   ini ;
        -:   75:
    #####:   76:    if ((ini = fopen ("plover.ini", "w")) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   77:    {
    #####:   78:        fprintf(stderr, "iniparser: cannot create plover.ini\n");
call    0 never executed
    #####:   79:        return ;
        -:   80:    }
        -:   81:
    #####:   82:    fprintf(ini,
call    0 never executed
        -:   83:    "[USERINFO]\n"
        -:   84:    "\n"
        -:   85:    "UUID	=	%s;\n"
        -:   86:    "\n", uDs.uuid);
        -:   87:
    #####:   88:    fclose(ini);
call    0 never executed
        -:   89:}
        -:   90:// end of func_MakeIni(); //
        -:   91:
        -:   92:// Parse IniFile //
function func_ParseIni called 0 returned 0% blocks executed 0%
    #####:   93:int  func_ParseIni (char * ini_name)
        -:   94:{
        -:   95:    dictionary *ini;
        -:   96:
        -:   97:    /* Some temporary variables to hold query results */
        -:   98:
    #####:   99:    ini = iniparser_load(ini_name);
call    0 never executed
    #####:  100:    if (ini==NULL)
branch  0 never executed
branch  1 never executed
        -:  101:    {
    #####:  102:        fprintf(stderr, "cannot parse file: %s\n", ini_name);
call    0 never executed
    #####:  103:        return -1 ;
        -:  104:    }
    #####:  105:    iniparser_dump (ini, stderr);
call    0 never executed
        -:  106:
        -:  107:    /* Get attributes */	
    #####:  108:    INI_UUID = iniparser_getstring (ini, "USERINFO:UUID", NULL);
call    0 never executed
    #####:  109:    strcpy (chk_uuid ,INI_UUID);
    #####:  110:    printf ("********** INI FILE **********.\n");
call    0 never executed
    #####:  111:    printf ("INI UUID:	[%s]\n", INI_UUID ? INI_UUID : "UNDEF");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  112:    
        -:  113:    //i = iniparser_getint(ini, "a:b", -1);
        -:  114:    //printf("a:	[%d]\n", i);
        -:  115:
    #####:  116:    iniparser_freedict (ini);
call    0 never executed
    #####:  117:    return 0 ;
        -:  118:}
        -:  119:// end of func_ParseIni(); //
        -:  120:
        -:  121:// Version Check #fvc//
function func_VerChk called 0 returned 0% blocks executed 0%
    #####:  122:int func_VerChk()
        -:  123:{
    #####:  124:	func_Send();
call    0 never executed
        -:  125:	//gtk_label_set_text(GTK_LABEL(e_verion_label), chk_ver); // fuc_send()의 flag(0)에서 chk_ver에 버전data넣어야함
    #####:  126:	chk_df = 1; // 사용자 확인해야함 //
        -:  127:
    #####:  128:	return chk_df;
        -:  129:}
        -:  130:// end of func_VerChk(); //
        -:  131:
        -:  132:// 계정이 있는지 확인: 1=없다 2=있다 #fuc //
function func_UsrChk called 0 returned 0% blocks executed 0%
    #####:  133:int func_UsrChk()
        -:  134:{
        -:  135:	int tmp;
        -:  136:
    #####:  137:	chk_df = 1;
    #####:  138:	func_Send();
call    0 never executed
    #####:  139:	tmp = strcmp (chk_uuid, uDs.uuid); // 클라이언트 흐름 다시 생각해보기. 실행부터
        -:  140:
    #####:  141:	if (tmp == 0)
branch  0 never executed
branch  1 never executed
        -:  142:	{
    #####:  143:		printf ("사용자님 안녕하세요!\n");
call    0 never executed
    #####:  144:		chk_df = 2;
        -:  145:	}
        -:  146:	else
        -:  147:	{
    #####:  148:		printf ("사용자 등록을 해주세요!\n");
call    0 never executed
    #####:  149:		chk_df = 1;
        -:  150:	}
        -:  151:	 
        -:  152:
    #####:  153:	if (chk_df == 1)
branch  0 never executed
branch  1 never executed
        -:  154:	{
    #####:  155:		gtk_widget_show (enrollment_window); // 사용자 등록 창 //
call    0 never executed
    #####:  156:		gtk_main();
call    0 never executed
        -:  157:	}
    #####:  158:	if (chk_df == 2)
branch  0 never executed
branch  1 never executed
        -:  159:	{
    #####:  160:		gtk_widget_show (main_window); 		// 메인 창 //
call    0 never executed
    #####:  161:		gtk_main();
call    0 never executed
        -:  162:	}
        -:  163:	
    #####:  164:	return chk_df;
        -:  165:}
        -:  166:/* end of func_UsrChk(); */
        -:  167:
        -:  168:// 사용자 UUID parsing #fuu//
function func_Uuid called 0 returned 0% blocks executed 0%
    #####:  169:int func_Uuid()
        -:  170:{
    #####:  171:	FILE *uidfp = NULL;
        -:  172:	char strbuf[300];
    #####:  173:	char *pstr = NULL;
        -:  174:
    #####:  175:	uidfp = fopen ("/etc/fstab", "r");
call    0 never executed
        -:  176:
    #####:  177:	if (NULL == uidfp)
branch  0 never executed
branch  1 never executed
        -:  178:	{
    #####:  179:        printf ("fstab 파일을 열수 없습니다.\n");
call    0 never executed
    #####:  180:		return 1;
        -:  181:	}
        -:  182:
    #####:  183:	while (feof (uidfp) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  184:	{
    #####:  185:		pstr = fgets (strbuf, sizeof(strbuf), uidfp);
call    0 never executed
        -:  186:
    #####:  187:		if (pstr != 0) // \n만나면 문자 더이상 안 읽어서 안해주면 seg fault 뜸 //
branch  0 never executed
branch  1 never executed
        -:  188:		{
    #####:  189:			if (pstr[0] == 'U' && pstr[42] == '/')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  190:			{
    #####:  191:				for (int i = 0; i < 36; i++)
branch  0 never executed
branch  1 never executed
        -:  192:				{ 
    #####:  193:					set_uuid[i] = pstr[i+5];
        -:  194:				}
    #####:  195:				strcpy (uDs.uuid, set_uuid);
    #####:  196:				strcpy (sfDs.uuid, set_uuid);
    #####:  197:				printf ("UUID: [%s]\n", uDs.uuid);
call    0 never executed
        -:  198:			}
        -:  199:		}
        -:  200:    }
        -:  201:    
    #####:  202:    memset (strbuf, 0, sizeof(strbuf));
    #####:  203:	fclose (uidfp);
call    0 never executed
        -:  204:
    #####:  205:	return 0;
        -:  206:}
        -:  207:// end of func_Uuid()(); //
        -:  208:
        -:  209:// 정규식 컴파일 //
function compile_regex called 0 returned 0% blocks executed 0%
    #####:  210:int compile_regex (regex_t *r, const char *regex_text)
        -:  211:{
    #####:  212:	int status = regcomp (r, regex_text, REG_EXTENDED|REG_NEWLINE);
call    0 never executed
        -:  213:
    #####:  214:	if (status != 0)
branch  0 never executed
branch  1 never executed
        -:  215:	{
        -:  216:		char error_message[MAX_ERROR_MSG];
        -:  217:
    #####:  218:		regerror (status, r, error_message, MAX_ERROR_MSG);
call    0 never executed
        -:  219:
    #####:  220:		printf ("Regex error compiling '%s': %s\n", regex_text, error_message);
call    0 never executed
        -:  221:
    #####:  222:		return 1;
        -:  223:	}
        -:  224:
    #####:  225:	return 0;
        -:  226:}
        -:  227:/* end of compile_regex(); */
        -:  228:
        -:  229:// 주민등록번호, 외국인등록번호 정규식 #jfr //
function match_regex_jnfg called 0 returned 0% blocks executed 0%
    #####:  230:char match_regex_jnfg (regex_t *r, const char *to_match, char *filepath, struct dirent *file, struct stat buf)
    #####:  231:{
        -:  232:	/* "P" is a pointer into the string which points to the end of the
        -:  233:	previous match. */
    #####:  234:	const char *p = to_match;
        -:  235:
        -:  236:	/* "M" contains the matches found. */
    #####:  237:	regmatch_t m[n_matches];
        -:  238:
        -:  239:	// 버퍼크기만큼 읽은 부분 전체를 해당 정규식과 비교 //
        -:  240:	while (1)
        -:  241:	{
    #####:  242:		nomatch = regexec (r, p, n_matches, m, 0);
call    0 never executed
        -:  243:
    #####:  244:		if (nomatch)
branch  0 never executed
branch  1 never executed
        -:  245:		{
        -:  246:			//printf("No more matches.\n");
    #####:  247:			printf("[%d] JF reading\n", z++);
call    0 never executed
    #####:  248:			return 0;
        -:  249:		}
        -:  250:
        -:  251:		else
        -:  252:		{
    #####:  253:			for (int i = 0; i < n_matches; i++)
branch  0 never executed
branch  1 never executed
        -:  254:			{
        -:  255:				int start;
        -:  256:
    #####:  257:				if (m[i].rm_so == -1)
branch  0 never executed
branch  1 never executed
        -:  258:				{
    #####:  259:					break;
        -:  260:				}
        -:  261:
    #####:  262:				start = m[i].rm_so + (p - to_match);
        -:  263:
        -:  264:				// 주민번호, 외국인등록번호 정규식 검사 통과 //
    #####:  265:				if (i == 0)
branch  0 never executed
branch  1 never executed
        -:  266:				{
    #####:  267:					int chk = 0, jtmp = 0, fgtmp = 0, sum = 0;
    #####:  268:					char buf_tmp[15] = {0,};
        -:  269:
        -:  270:					// 주민번호, 외국인등록번호 유효성 검사 //
    #####:  271:					for (int j = 0; j < 14; j++)
branch  0 never executed
branch  1 never executed
        -:  272:					{
    #####:  273:						buf_tmp[j] = *(to_match + start + j);
    #####:  274:						buf_tmp[j] -= 48;
        -:  275:					}
        -:  276:
    #####:  277:					sum = buf_tmp[0]*2 + buf_tmp[1]*3 + buf_tmp[2]*4 + buf_tmp[3]*5 + buf_tmp[4]*6 + buf_tmp[5]*7
    #####:  278:					+ buf_tmp[7]*8 + buf_tmp[8]*9 + buf_tmp[9]*2 + buf_tmp[10]*3 + buf_tmp[11]*4 + buf_tmp[12]*5;
        -:  279:
    #####:  280:					chk = buf_tmp[13];
    #####:  281:					jtmp = 11 - (sum % 11); // 주민번호 //
    #####:  282:					fgtmp = 13 - (sum % 11); // 외국인번호 //
        -:  283:
    #####:  284:					if (jtmp >= 10)
branch  0 never executed
branch  1 never executed
        -:  285:					{
    #####:  286:						jtmp -= 10;
        -:  287:					}
        -:  288:
    #####:  289:					if (fgtmp >= 10)
branch  0 never executed
branch  1 never executed
        -:  290:					{
    #####:  291:						fgtmp -= 10;
        -:  292:					}
        -:  293:
        -:  294:					// 주민번호 유효성 통과 //
    #####:  295:					if (jtmp == chk)
branch  0 never executed
branch  1 never executed
        -:  296:					{
    #####:  297:						int res = strcmp (chk_fname, file->d_name); // 같은파일 = 0 //
        -:  298:
    #####:  299:						if (res != 0)
branch  0 never executed
branch  1 never executed
        -:  300:						{
    #####:  301:							chk_fcnt++;
        -:  302:						}
        -:  303:
        -:  304:					// 읽고있는중인 파일 이름 저장 //
    #####:  305:					strcpy (chk_fname, file->d_name);
        -:  306:
        -:  307:					// 검출된 주민등록번호의 수 //
    #####:  308:					fDs[chk_fcnt].jcnt++;
        -:  309:
        -:  310:					// data 구조체에 저장 //
    #####:  311:					strcpy (fDs[chk_fcnt].fpath, filepath);
    #####:  312:					strcpy (fDs[chk_fcnt].fname, file->d_name);
    #####:  313:					fDs [chk_fcnt].fsize = buf.st_size;
    #####:  314:					strcpy (fDs[chk_fcnt].stat, "일반");
        -:  315:
        -:  316:					}
        -:  317:
        -:  318:					// 외국인등록번호 유효성 통과 //
    #####:  319:					if (fgtmp == chk)
branch  0 never executed
branch  1 never executed
        -:  320:					{
    #####:  321:						int res = strcmp (chk_fname, file->d_name); // 같은파일 = 0 //
        -:  322:
    #####:  323:						if (res != 0)
branch  0 never executed
branch  1 never executed
        -:  324:						{
    #####:  325:							chk_fcnt++;
        -:  326:						}
        -:  327:
        -:  328:					// 읽고있는중인 파일 이름 저장 //
    #####:  329:					strcpy (chk_fname, file->d_name);
        -:  330:
        -:  331:					// 검출된 외국인등록번호의 수 //
    #####:  332:					fDs[chk_fcnt].fgcnt++;
        -:  333:
        -:  334:					// data 구조체에 저장 //
    #####:  335:					strcpy (fDs[chk_fcnt].fpath, filepath);
    #####:  336:					strcpy (fDs[chk_fcnt].fname, file->d_name);
    #####:  337:					fDs[chk_fcnt].fsize = buf.st_size;
    #####:  338:					strcpy (fDs[chk_fcnt].stat, "일반");
        -:  339:
        -:  340:					}
        -:  341:				}
        -:  342:			}
        -:  343:		}
        -:  344:
    #####:  345:		p += m[0].rm_eo;
        -:  346:	}
        -:  347:}
        -:  348:/* end of match_regex_jnfg(); */
        -:  349:
        -:  350:// 운전면허 정규식 #dr //
function match_regex_d called 0 returned 0% blocks executed 0%
    #####:  351:char match_regex_d (regex_t *r, const char *to_match, char *filepath, struct dirent *file, struct stat buf)
    #####:  352:{
    #####:  353:	const char *p = to_match;
        -:  354:
    #####:  355:	regmatch_t m[n_matches];
        -:  356:
        -:  357:	//버퍼크기만큼 읽은 부분 전체를 해당 정규식과 비교//
        -:  358:	while (1)
        -:  359:	{
    #####:  360:		nomatch = regexec(r, p, n_matches, m, 0);
call    0 never executed
        -:  361:
    #####:  362:		if (nomatch)
branch  0 never executed
branch  1 never executed
        -:  363:		{
        -:  364:			//printf("No more matches.\n");
    #####:  365:			printf ("[%d] D reading\n", x++);
call    0 never executed
    #####:  366:			return 0;
        -:  367:		}
        -:  368:
        -:  369:		else
        -:  370:		{
    #####:  371:			for (int i = 0; i < n_matches; i++)
branch  0 never executed
branch  1 never executed
        -:  372:			{
    #####:  373:				if (m[i].rm_so == -1)
branch  0 never executed
branch  1 never executed
        -:  374:				{
    #####:  375:				    break;
        -:  376:				}
        -:  377:
        -:  378:				//운전면허 정규식 검사 통과//
    #####:  379:				if (i == 0)
branch  0 never executed
branch  1 never executed
        -:  380:				{
    #####:  381:					int res = strcmp (chk_fname, file->d_name); //같은파일 = 0 //
        -:  382:
    #####:  383:					if (res != 0)
branch  0 never executed
branch  1 never executed
        -:  384:					{
    #####:  385:						chk_fcnt++;
        -:  386:					}
        -:  387:
        -:  388:					// 읽고있는중인 파일 이름 저장 //
    #####:  389:					strcpy (chk_fname, file->d_name);
        -:  390:
        -:  391:					// 검출된 운전면허의 수 //
    #####:  392:					fDs[chk_fcnt].dcnt++;
        -:  393:
        -:  394:					// data 구조체에 저장 //
    #####:  395:					strcpy (fDs[chk_fcnt].fpath, filepath);
    #####:  396:					strcpy (fDs[chk_fcnt].fname, file->d_name);
    #####:  397:					fDs[chk_fcnt].fsize = buf.st_size;
    #####:  398:					strcpy (fDs[chk_fcnt].stat, "일반");
        -:  399:
        -:  400:				}
        -:  401:			}
        -:  402:		}
        -:  403:
    #####:  404:		p += m[0].rm_eo;
        -:  405:	}
        -:  406:}
        -:  407:/* end of match_regex_d(); */
        -:  408:
        -:  409:// 여권번호 정규식 #pr //
function match_regex_p called 0 returned 0% blocks executed 0%
    #####:  410:char match_regex_p (regex_t *r, const char *to_match, char *filepath, struct dirent *file, struct stat buf)
    #####:  411:{
    #####:  412:	const char *p = to_match;
        -:  413:
    #####:  414:	regmatch_t m[n_matches];
        -:  415:
        -:  416:	// 버퍼크기만큼 읽은 부분 전체를 해당 정규식과 비교 //
        -:  417:	while (1)
        -:  418:	{
    #####:  419:		nomatch = regexec (r, p, n_matches, m, 0);
call    0 never executed
        -:  420:
    #####:  421:		if (nomatch)
branch  0 never executed
branch  1 never executed
        -:  422:		{
        -:  423:			//printf("No more matches.\n");
    #####:  424:			printf("[%d] P reading\n", y++);
call    0 never executed
    #####:  425:			return 0;
        -:  426:		}
        -:  427:
        -:  428:		else
        -:  429:		{
    #####:  430:			for (int i = 0; i < n_matches; i++)
branch  0 never executed
branch  1 never executed
        -:  431:			{
    #####:  432:				if (m[i].rm_so == -1)
branch  0 never executed
branch  1 never executed
        -:  433:				{
    #####:  434:					break;
        -:  435:				}
        -:  436:
        -:  437:				// 운전면허 정규식 검사 통과 //
    #####:  438:				if (i == 0)
branch  0 never executed
branch  1 never executed
        -:  439:				{
    #####:  440:					int res = strcmp (chk_fname, file->d_name); // 같은파일 = 0 //
        -:  441:
    #####:  442:					if (res != 0)
branch  0 never executed
branch  1 never executed
        -:  443:					{
    #####:  444:						chk_fcnt++;
        -:  445:					}
        -:  446:
        -:  447:					// 읽고있는중인 파일 이름 저장 //
    #####:  448:					strcpy (chk_fname, file->d_name);
        -:  449:
        -:  450:					// 검출된 운전면허의 수 //
    #####:  451:					fDs[chk_fcnt].pcnt++;
        -:  452:
        -:  453:					// data 구조체에 저장 //
    #####:  454:					strcpy (fDs[chk_fcnt].fpath, filepath);
    #####:  455:					strcpy (fDs[chk_fcnt].fname, file->d_name);
    #####:  456:					fDs[chk_fcnt].fsize = buf.st_size;
    #####:  457:					strcpy (fDs[chk_fcnt].stat, "일반");
        -:  458:
        -:  459:				}
        -:  460:			}
        -:  461:		}
        -:  462:
    #####:  463:		p += m[0].rm_eo;
        -:  464:	}
        -:  465:}
        -:  466:/* end of match_regex_p(); */
        -:  467:
        -:  468:// data 종류 확인 //
function check_kind_of_data called 0 returned 0% blocks executed 0%
    #####:  469:void check_kind_of_data (const char *to_match, char *filepath, struct dirent *file, struct stat buf)
        -:  470:{
        -:  471:	regex_t r;
        -:  472:	const char *regex_text;
        -:  473:
        -:  474:	/*
        -:  475:	switch(data_flag) //나중에 민감정보 종류 선택 검출 할 때 사용
        -:  476:	{
        -:  477:		case 1:
        -:  478:			regex_text = "([0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[1,2][0-9]|3[0,1])-[1-4][0-9]{6})"; //주민번호 정규식//
        -:  479:			compile_regex(&r, regex_text); //정규식 컴파일//
        -:  480:			match_regex_j(&r, to_match, filepath, file, buf);
        -:  481:
        -:  482:			break;
        -:  483:
        -:  484:		case 2:
        -:  485:			regex_text = "[0-9]{2}-[0-9]{6}-[0-9]{2}"; //운전면허 정규식//
        -:  486:			compile_regex(&r, regex_text); //정규식 컴파일//
        -:  487:			//match_regex_d(&r, to_match, filepath, file, buf);
        -:  488:	}
        -:  489:	*/
        -:  490:
        -:  491:	// 주민번호, 외국인등록번호 정규식 //
    #####:  492:	regex_text = "([0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[1,2][0-9]|3[0,1])-[1-4][0-9]{6})";
    #####:  493:	compile_regex(&r, regex_text); // 정규식 컴파일 //
call    0 never executed
    #####:  494:	match_regex_jnfg(&r, to_match, filepath, file, buf);
call    0 never executed
        -:  495:
        -:  496:	// 운전면허 정규식 //
    #####:  497:	regex_text = "[0-9]{2}-[0-9]{6}-[0-9]{2}";
    #####:  498:	compile_regex (&r, regex_text); // 정규식 컴파일 //
call    0 never executed
    #####:  499:	match_regex_d (&r, to_match, filepath, file, buf);
call    0 never executed
        -:  500:
        -:  501:	// 여권번호 정규식 //
    #####:  502:	regex_text = "[a-zA-Z]{2}[0-9]{7}";
    #####:  503:	compile_regex (&r, regex_text); // 정규식 컴파일 //
call    0 never executed
    #####:  504:	match_regex_p (&r, to_match, filepath, file, buf);
call    0 never executed
        -:  505:
    #####:  506:	return;
        -:  507:}
        -:  508:/* end of check_kind_of_data(); */
        -:  509:
        -:  510:// 폴더, 파일 스캔 후 검출 #fd //
function func_Detect called 0 returned 0% blocks executed 0%
    #####:  511:int func_Detect (gchar *path)
        -:  512:{
    #####:  513:	DIR *dp = NULL;
    #####:  514:	FILE *fp = NULL;
    #####:  515:	struct dirent *file = NULL;
        -:  516:	struct stat buf;
        -:  517:	char filepath[300];
        -:  518:	char buffer[2097152];
        -:  519:	const char *find_text;
        -:  520:
    #####:  521:	if ((dp = opendir(path)) == NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  522:	{
    #####:  523:		printf("폴더를 열수 없습니다.\n");
call    0 never executed
    #####:  524:		return -1;
        -:  525:	}
    #####:  526:	while ((file = readdir(dp)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  527:	{
        -:  528:	// filepath에 현재 path넣기 //
    #####:  529:	sprintf (filepath, "%s/%s", path, file->d_name);
    #####:  530:	lstat (filepath, &buf);
call    0 never executed
        -:  531:		// 폴더 //
    #####:  532:		if (S_ISDIR (buf.st_mode))
branch  0 never executed
branch  1 never executed
        -:  533:		{
        -:  534:			// .이거하고 ..이거 제외 //
    #####:  535:			if ((!strcmp (file->d_name, ".")) || (!strcmp (file->d_name, "..")))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  536:			{
    #####:  537:				continue;
        -:  538:			}
        -:  539:			// 안에 폴더로 재귀함수 //
    #####:  540:			func_Detect(filepath);
call    0 never executed
        -:  541:		}
        -:  542:		// 파일 //
    #####:  543:		else if (S_ISREG (buf.st_mode))
branch  0 never executed
branch  1 never executed
        -:  544:		{
    #####:  545:			fp = fopen (filepath, "r");
call    0 never executed
    #####:  546:			if (NULL == fp)
branch  0 never executed
branch  1 never executed
        -:  547:			{
    #####:  548:				printf("파일을 열수 없습니다.\n");
call    0 never executed
    #####:  549:				return 1;
        -:  550:			}
        -:  551:			// 버퍼 크기만큼 읽고 find_text에 넣어서 정규식검사로 이동 //
    #####:  552:			while (feof (fp) == 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  553:			{
    #####:  554:				fread (buffer, sizeof (char), sizeof (buffer), fp);
call    0 never executed
    #####:  555:				find_text = buffer;
    #####:  556:				check_kind_of_data (find_text, filepath, file, buf);
call    0 never executed
    #####:  557:				find_text = NULL;
        -:  558:			}
        -:  559:			// 메모리관리(초기화), 파일닫기 //
    #####:  560:			memset (buffer, 0, sizeof (buffer));
    #####:  561:			fclose (fp);
call    0 never executed
    #####:  562:			printf ("Close FILE\n");
call    0 never executed
    #####:  563:			chk_fname[0] = 0; // 초기화 //
        -:  564:		}
        -:  565:	}
        -:  566:
    #####:  567:	closedir (dp);
call    0 never executed
        -:  568:
    #####:  569:	printf ("Close DIR\n");
call    0 never executed
        -:  570:
    #####:  571:	return  0;
        -:  572:}
        -:  573:/* end of func_Detect(); */
        -:  574:
        -:  575:// RabbitMQ 소켓, 채널 열기 //
function func_SetRabbit called 0 returned 0% blocks executed 0%
    #####:  576:int func_SetRabbit()
        -:  577:{
    #####:  578:	port		=	PORT;
    #####:  579:	vhost		=	VHOST;
    #####:  580:	username	=	USERNAME;
    #####:  581:	password	=	PASSWORD;
        -:  582:
        -:  583:	/*
        -:  584:	 establish a channel that is used to connect RabbitMQ server
        -:  585:	*/
    #####:  586:	conn = amqp_new_connection();
call    0 never executed
        -:  587:
    #####:  588:	socket = amqp_tcp_socket_new (conn);
call    0 never executed
    #####:  589:	if (!socket)
branch  0 never executed
branch  1 never executed
        -:  590:	{
    #####:  591:		die ("creating TCP socket");
call    0 never executed
        -:  592:	}
    #####:  593:	status = amqp_socket_open (socket, HOSTNAME, port);
call    0 never executed
        -:  594:	
    #####:  595:	if (status)
branch  0 never executed
branch  1 never executed
        -:  596:	{
    #####:  597:		die("opening TCP socket");
call    0 never executed
        -:  598:	}
        -:  599:
        -:  600:
    #####:  601:	die_on_amqp_error (amqp_login (conn, "/", 0, 131072, 0, AMQP_SASL_METHOD_PLAIN,
call    0 never executed
call    1 never executed
        -:  602:																		"guest", "guest"),
        -:  603:																		"Logging in");
        -:  604:	/*die_on_amqp_error(amqp_login(conn, vhost, 200, 131072, 0, AMQP_SASL_METHOD_PLAIN,
        -:  605:																		username, password),
        -:  606:																		"Logging in");*/
        -:  607:					
    #####:  608:	amqp_channel_open (conn, 1);
call    0 never executed
    #####:  609:	die_on_amqp_error (amqp_get_rpc_reply (conn), "Opening channel");
call    0 never executed
call    1 never executed
        -:  610:
        -:  611:	/*
        -:  612:	 create private reply_to queue
        -:  613:	*/
        -:  614:	{
    #####:  615:		amqp_queue_declare_ok_t *r = amqp_queue_declare (
call    0 never executed
        -:  616:			conn, 1, amqp_empty_bytes, 0, 0, 0, 1, amqp_empty_table);
        -:  617:
    #####:  618:		die_on_amqp_error (amqp_get_rpc_reply (conn), "Declaring queue");
call    0 never executed
call    1 never executed
        -:  619:
    #####:  620:		reply_to_queue = amqp_bytes_malloc_dup (r->queue);
call    0 never executed
    #####:  621:		if (reply_to_queue.bytes == NULL)
branch  0 never executed
branch  1 never executed
        -:  622:		{
    #####:  623:			fprintf (stderr, "Out of memory while copying queue name");
call    0 never executed
    #####:  624:			return 1;
        -:  625:		}
        -:  626:	}
        -:  627:
    #####:  628:	return 0;
        -:  629:}
        -:  630:
        -:  631:// 전송 #fs //
function func_Send called 0 returned 0% blocks executed 0%
    #####:  632:int func_Send()
        -:  633:{
        -:  634:	static char *enc;
        -:  635:	char message[1024];
    #####:  636:	gdouble percent = 0.0;
    #####:  637:	size_t in_len = 0;
        -:  638:	//routingkey = "ka"; // TRCODE //
        -:  639:
        -:  640:	/*
        -:  641:	 send the message
        -:  642:	*/
        -:  643:	{
        -:  644:		/*
        -:  645:		  set properties
        -:  646:		*/
        -:  647:		amqp_basic_properties_t props;
    #####:  648:		props._flags = AMQP_BASIC_CONTENT_TYPE_FLAG |
        -:  649:					   AMQP_BASIC_DELIVERY_MODE_FLAG | AMQP_BASIC_REPLY_TO_FLAG |
        -:  650:					   AMQP_BASIC_CORRELATION_ID_FLAG;
    #####:  651:		props.content_type = amqp_cstring_bytes("text/plain");
call    0 never executed
    #####:  652:		props.delivery_mode = 2; /* persistent delivery mode */
    #####:  653:		props.reply_to = amqp_bytes_malloc_dup(reply_to_queue);
call    0 never executed
        -:  654:		
    #####:  655:		if (props.reply_to.bytes == NULL)
branch  0 never executed
branch  1 never executed
        -:  656:		{
    #####:  657:			fprintf (stderr, "Out of memory while copying queue name");
call    0 never executed
    #####:  658:			return 1;
        -:  659:		}
    #####:  660:		props.correlation_id = amqp_cstring_bytes ("1");
call    0 never executed
        -:  661:
        -:  662:		/*
        -:  663:		  publish // 어떤데이터를 보낼지 chk_df로 구분 #data_sending
        -:  664:		*/
    #####:  665:		switch (chk_df)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:  666:		{
    #####:  667:			case 0:	// 버전 확인 //
    #####:  668:				printf ("##### 버전 확인 #####\n");
call    0 never executed
        -:  669:				//routingkey = "BPVCHK0R"; // TRCODE //
    #####:  670:				routingkey = "ka";
    #####:  671:				enc = "Version Check";
    #####:  672:				die_on_error (amqp_basic_publish (conn, 1, amqp_cstring_bytes (EXCHANGE),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  673:									amqp_cstring_bytes (routingkey), 0, 0,
        -:  674:									&props, amqp_cstring_bytes (enc)), "Publishing");
    #####:  675:				break;
        -:  676:
    #####:  677:			case 1:	// 사용자 확인 //
    #####:  678:				printf ("##### 사용자 확인 #####\n");
call    0 never executed
    #####:  679:				routingkey = "ka"; // TRCODE //
    #####:  680:				enc = "User Check";
    #####:  681:				die_on_error (amqp_basic_publish (conn, 1, amqp_cstring_bytes (EXCHANGE),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  682:									amqp_cstring_bytes (routingkey), 0, 0,
        -:  683:									&props, amqp_cstring_bytes (enc)), "Publishing");
    #####:  684:				break;
        -:  685:			
    #####:  686:			case 2:	// 사용자 등록 //
    #####:  687:				printf("##### 사용자 등록 #####\n");
call    0 never executed
        -:  688:				//routingkey = "BPDEPT0R"; // TRCODE //
    #####:  689:				routingkey = "ka";
    #####:  690:				in_len = sizeof (uDs);
    #####:  691:				enc = b64_encode ((unsigned char *)&uDs, in_len, enc);
call    0 never executed
    #####:  692:				printf ("[enc_data: %s]\n", enc);
call    0 never executed
    #####:  693:				printf ("[UUID: %s, %s/%s/%s]\n\n", uDs.uuid, uDs.udept, uDs.uname, uDs.ujob);
call    0 never executed
        -:  694:				
    #####:  695:				die_on_error (amqp_basic_publish (conn, 1, amqp_cstring_bytes (EXCHANGE),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  696:									amqp_cstring_bytes (routingkey), 0, 0,
        -:  697:									&props, amqp_cstring_bytes (enc)), "Publishing");
    #####:  698:				break;
        -:  699:
    #####:  700:			case 3:	// 검출 결과 //
    #####:  701:				printf ("##### 검출 결과  #####\n");
call    0 never executed
    #####:  702:				routingkey = "ka"; // TRCODE //
    #####:  703:				memset (message, 0x00, strlen(message));
    #####:  704:				for (int i = 0; i <= chk_fcnt; i++)
branch  0 never executed
branch  1 never executed
        -:  705:				{
    #####:  706:					percent = 100.0;
    #####:  707:					strcpy (fDs[i].uuid, uDs.uuid);
    #####:  708:					in_len = sizeof(fDs[i]);
        -:  709:					//printf("fds[%d]: %ld\n", i ,in_len); //구조체 크기확인
    #####:  710:					enc = b64_encode ((unsigned char *)&fDs[i], in_len, enc);
call    0 never executed
    #####:  711:					printf ("[enc_data: %s]\n", enc);
call    0 never executed
    #####:  712:					printf ("[UUID: %s, cnt: %d, jumin: %d, driver: %d, forign: %d, pass: %d, fsize: %d, fstat: %s, fpath: %s]\n\n",
    #####:  713:								fDs[i].uuid, i, fDs[i].jcnt, fDs[i].dcnt, fDs[i].fgcnt, fDs[i].pcnt, fDs[i].fsize, fDs[i].stat, fDs[i].fpath);
call    0 never executed
    #####:  714:					sprintf ( message, "%.0f%% Complete", percent);
    #####:  715:					gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (d_progressbar), percent);
call    0 never executed
call    1 never executed
    #####:  716:					gtk_progress_bar_set_text (GTK_PROGRESS_BAR (d_progressbar), message);
call    0 never executed
call    1 never executed
        -:  717:
    #####:  718:					die_on_error (amqp_basic_publish (conn, 1, amqp_cstring_bytes (EXCHANGE),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  719:									amqp_cstring_bytes (routingkey), 0, 0,
        -:  720:									&props, amqp_cstring_bytes (enc)), "Publishing");
        -:  721:				}
    #####:  722:				break;
        -:  723:
    #####:  724:			case 4:	// 파일 삭제 //
    #####:  725:				printf ("##### 파일 삭제  #####\n");
call    0 never executed
    #####:  726:				routingkey = "ka"; // TRCODE //
    #####:  727:				in_len = sizeof (sfDs);
    #####:  728:				enc = b64_encode ((unsigned char *)&sfDs, in_len, enc);
call    0 never executed
    #####:  729:				printf ("[enc_data: %s]\n", enc);
call    0 never executed
        -:  730:				
    #####:  731:				die_on_error (amqp_basic_publish (conn, 1, amqp_cstring_bytes (EXCHANGE),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  732:									amqp_cstring_bytes (routingkey), 0, 0,
        -:  733:									&props, amqp_cstring_bytes (enc)), "Publishing");
    #####:  734:				break;
        -:  735:				
    #####:  736:			case 5:	// 파일 암호화 //
    #####:  737:				printf ("##### 파일 암호화  #####\n");
call    0 never executed
    #####:  738:				routingkey = "ka"; // TRCODE //
    #####:  739:				in_len = sizeof (sfDs);
    #####:  740:				enc = b64_encode ((unsigned char *)&sfDs, in_len, enc);
call    0 never executed
    #####:  741:				printf ("[enc_data: %s]\n", enc);
call    0 never executed
        -:  742:				
    #####:  743:				die_on_error (amqp_basic_publish (conn, 1, amqp_cstring_bytes (EXCHANGE),
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
call    4 never executed
        -:  744:									amqp_cstring_bytes (routingkey), 0, 0,
        -:  745:									&props, amqp_cstring_bytes (enc)), "Publishing");
    #####:  746:				break;
        -:  747:
        -:  748:		}
        -:  749:
    #####:  750:		amqp_bytes_free (props.reply_to);
call    0 never executed
        -:  751:	}
        -:  752:	
        -:  753:	
        -:  754:	/*
        -:  755:	wait an answer //응답도 case이용해서 flag별로 구분해야 할듯
        -:  756:	*/
        -:  757:	/*
        -:  758:	{
        -:  759:		amqp_basic_consume(conn, 1, reply_to_queue, amqp_empty_bytes, 0, 1, 0,
        -:  760:								amqp_empty_table);
        -:  761:		die_on_amqp_error(amqp_get_rpc_reply(conn), "Consuming");
        -:  762:
        -:  763:
        -:  764:		{
        -:  765:			amqp_frame_t frame;
        -:  766:			int result;
        -:  767:
        -:  768:			amqp_basic_deliver_t *d;
        -:  769:			amqp_basic_properties_t *p;
        -:  770:			size_t body_target;
        -:  771:			size_t body_received;
        -:  772:
        -:  773:			for (;;)
        -:  774:			{
        -:  775:				amqp_maybe_release_buffers(conn);
        -:  776:				result = amqp_simple_wait_frame(conn, &frame);
        -:  777:				printf("Result: %d\n", result);
        -:  778:			
        -:  779:				if (result < 0)
        -:  780:				{
        -:  781:					break;
        -:  782:				}
        -:  783:
        -:  784:				printf("Frame type: %u channel: %u\n", frame.frame_type, frame.channel);
        -:  785:				if (frame.frame_type != AMQP_FRAME_METHOD)
        -:  786:				{
        -:  787:					continue;
        -:  788:				}
        -:  789:
        -:  790:				printf("Method: %s\n", amqp_method_name(frame.payload.method.id));
        -:  791:				if (frame.payload.method.id != AMQP_BASIC_DELIVER_METHOD)
        -:  792:				{
        -:  793:					continue;
        -:  794:				}
        -:  795:
        -:  796:				d = (amqp_basic_deliver_t *)frame.payload.method.decoded;
        -:  797:				printf("Delivery: %u exchange: %.*s routingkey: %.*s\n",
        -:  798:					   (unsigned)d->delivery_tag, (int)d->exchange.len,
        -:  799:					   (char *)d->exchange.bytes, (int)d->routing_key.len,
        -:  800:					   (char *)d->routing_key.bytes);
        -:  801:
        -:  802:				result = amqp_simple_wait_frame(conn, &frame);
        -:  803:				if (result < 0)
        -:  804:				{
        -:  805:					break;
        -:  806:				}
        -:  807:
        -:  808:				if (frame.frame_type != AMQP_FRAME_HEADER)
        -:  809:				{
        -:  810:					fprintf(stderr, "Expected header!");
        -:  811:					abort();
        -:  812:				}
        -:  813:				p = (amqp_basic_properties_t *)frame.payload.properties.decoded;
        -:  814:				if (p->_flags & AMQP_BASIC_CONTENT_TYPE_FLAG)
        -:  815:				{
        -:  816:					printf("Content-type: %.*s\n", (int)p->content_type.len,
        -:  817:						 (char *)p->content_type.bytes);
        -:  818:				}
        -:  819:				printf("----\n");
        -:  820:
        -:  821:				body_target = (size_t)frame.payload.properties.body_size;
        -:  822:				body_received = 0;
        -:  823:
        -:  824:				while (body_received < body_target)
        -:  825:				{
        -:  826:					result = amqp_simple_wait_frame(conn, &frame);
        -:  827:					
        -:  828:					if (result < 0)
        -:  829:					{
        -:  830:						break;
        -:  831:					}
        -:  832:
        -:  833:					if (frame.frame_type != AMQP_FRAME_BODY)
        -:  834:					{
        -:  835:						fprintf(stderr, "Expected body!");
        -:  836:						abort();
        -:  837:					}
        -:  838:
        -:  839:					body_received += frame.payload.body_fragment.len;
        -:  840:					assert(body_received <= body_target);
        -:  841:
        -:  842:					amqp_dump(frame.payload.body_fragment.bytes,
        -:  843:								frame.payload.body_fragment.len);
        -:  844:				}
        -:  845:
        -:  846:				if (body_received != body_target)
        -:  847:				{
        -:  848:					// Can only happen when amqp_simple_wait_frame returns <= 0 //
        -:  849:					// We break here to close the connection //
        -:  850:					break;
        -:  851:				}
        -:  852:
        -:  853:				// everything was fine, we can quit now because we received the reply //
        -:  854:				break;
        -:  855:			}
        -:  856:		}
        -:  857:	}
        -:  858:	*/
        -:  859:
        -:  860:
        -:  861:	/*
        -:  862:	 closing
        -:  863:	*/
        -:  864:	//die_on_amqp_error(amqp_channel_close(conn, 1, AMQP_REPLY_SUCCESS), "Closing channel");
        -:  865:															
        -:  866:	//die_on_amqp_error(amqp_connection_close(conn, AMQP_REPLY_SUCCESS), "Closing connection");
        -:  867:															
        -:  868:	//die_on_error(amqp_destroy_connection(conn), "Ending connection");
        -:  869:
    #####:  870:	return TRUE;
        -:  871:}
        -:  872:/* end of func_Send(); */
        -:  873:
        -:  874:// gtk_dialog_modal //
function func_gtk_dialog_modal called 0 returned 0% blocks executed 0%
    #####:  875:int func_gtk_dialog_modal (int type, GtkWidget *widget, char *message)
        -:  876:{
        -:  877:	GtkWidget *dialog, *label, *content_area;
    #####:  878:	GtkDialogFlags flags = GTK_DIALOG_MODAL;
    #####:  879:	int	rtn = GTK_RESPONSE_REJECT;
        -:  880:
    #####:  881:	switch (type)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  882:	{
    #####:  883:		case 0 :
    #####:  884:			dialog = gtk_dialog_new_with_buttons ("Dialog", GTK_WINDOW (widget), flags, 
call    0 never executed
call    1 never executed
        -:  885:						("_OK"), GTK_RESPONSE_ACCEPT, NULL );
    #####:  886:			break;
        -:  887:
    #####:  888:		case 1 :
    #####:  889:			dialog = gtk_dialog_new_with_buttons ("Dialog", GTK_WINDOW (widget), flags,
call    0 never executed
call    1 never executed
        -:  890:						("_OK"), GTK_RESPONSE_ACCEPT, 
        -:  891:						("_Cancel"), GTK_RESPONSE_REJECT, NULL);
    #####:  892:			break;
        -:  893:
    #####:  894:		default :
    #####:  895:			break;
        -:  896:	}
        -:  897:
    #####:  898:	label=gtk_label_new (message);
call    0 never executed
    #####:  899:	content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
call    0 never executed
call    1 never executed
    #####:  900:	gtk_container_add (GTK_CONTAINER (content_area), label);
call    0 never executed
call    1 never executed
    #####:  901:	gtk_widget_show_all (dialog);
call    0 never executed
        -:  902:
    #####:  903:	rtn = gtk_dialog_run (GTK_DIALOG (dialog));
call    0 never executed
call    1 never executed
    #####:  904:	gtk_widget_destroy (dialog);
call    0 never executed
    #####:  905:	return (rtn);	
        -:  906:}
        -:  907:
        -:  908:// 삭제 #delete //
function func_file_eraser called 0 returned 0% blocks executed 0%
    #####:  909:int func_file_eraser (int type)
        -:  910:{
        -:  911:	FILE *fp;
    #####:  912:	int mode = R_OK | W_OK;
        -:  913:	char MsgTmp[5];
    #####:  914:	uint size = 0;
        -:  915:	char *msize;
        -:  916:
    #####:  917:	if (access (sfDs.fpath, mode) != 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  918:	{
    #####:  919:		func_gtk_dialog_modal (0, window, "\n    파일이 삭제 가능한 상태가 아닙니다.    \n");
call    0 never executed
        -:  920:	}
        -:  921:	
        -:  922:	else
        -:  923:	{
    #####:  924:		msize = malloc (ERASER_SIZE);
    #####:  925:		fp = fopen (sfDs.fpath, "w");
call    0 never executed
        -:  926:
    #####:  927:		for (int i=0 ; i < type ; i++)
branch  0 never executed
branch  1 never executed
        -:  928:		{
    #####:  929:			while (size < sfDs.fsize)
branch  0 never executed
branch  1 never executed
        -:  930:			{
    #####:  931:				switch (i)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  932:				{
    #####:  933:					case 0 :
    #####:  934:						MsgTmp[0] = 'A';
    #####:  935:						memset( msize, MsgTmp[0], ERASER_SIZE );
    #####:  936:						break;
        -:  937:						
    #####:  938:					case 1 :
    #####:  939:						MsgTmp[0] = '^';
    #####:  940:						memset( msize, MsgTmp[0], ERASER_SIZE );
    #####:  941:						break;
        -:  942:						
    #####:  943:					case 2 :
    #####:  944:						srand(time(NULL));
call    0 never executed
call    1 never executed
    #####:  945:						if( size < ERASER_SIZE )
branch  0 never executed
branch  1 never executed
    #####:  946:							for( int j=0 ; j < ERASER_SIZE ; j++ )
branch  0 never executed
branch  1 never executed
    #####:  947:								msize[j] = 'A' + (random() % 26);
call    0 never executed
    #####:  948:						break;
        -:  949:						
    #####:  950:					case 3 :
    #####:  951:						MsgTmp[0] = 'Z';
    #####:  952:						memset( msize, MsgTmp[0], ERASER_SIZE );
    #####:  953:						break;
        -:  954:						
    #####:  955:					case 4 :
    #####:  956:						MsgTmp[0] = 'A';
    #####:  957:						memset( msize, MsgTmp[0], ERASER_SIZE );
    #####:  958:						break;
        -:  959:						
    #####:  960:					case 5 :
    #####:  961:						MsgTmp[0] = '^';
    #####:  962:						memset( msize, MsgTmp[0], ERASER_SIZE );
    #####:  963:						break;
        -:  964:						
    #####:  965:					case 6 :
    #####:  966:						srand(time(NULL));
call    0 never executed
call    1 never executed
    #####:  967:						if( size < ERASER_SIZE )
branch  0 never executed
branch  1 never executed
    #####:  968:							for( int j=0 ; j < ERASER_SIZE ; j++ )
branch  0 never executed
branch  1 never executed
    #####:  969:								msize[j] = 'A' + (random() % 26);
call    0 never executed
    #####:  970:						break;
        -:  971:						
    #####:  972:					default :
    #####:  973:						break;
        -:  974:				}
        -:  975:				
    #####:  976:				size += ERASER_SIZE;
        -:  977:			}
        -:  978:
    #####:  979:			fseek (fp, 0L, SEEK_SET);
call    0 never executed
        -:  980:		}
        -:  981:		
    #####:  982:		fclose (fp);
call    0 never executed
    #####:  983:		free (msize);
        -:  984:	}
        -:  985:
    #####:  986:	remove (sfDs.fpath);
call    0 never executed
    #####:  987:	func_gtk_dialog_modal (0, window, "\n    삭제가 완료되었습니다.    \n");
call    0 never executed
        -:  988:
    #####:  989:	chk_df = 4;
        -:  990:
    #####:  991:	return (TRUE);
        -:  992:}
        -:  993:// end of func_file_eraser(); //
        -:  994:
        -:  995:// 암호화 #aria //
function func_ARIA called 0 returned 0% blocks executed 0%
    #####:  996:void func_ARIA ()
        -:  997:{
        -:  998:	char message[1134];
        -:  999:	FILE *fp;
        -: 1000:	long lSize;
        -: 1001:	unsigned char *buff;
    #####: 1002:	uint cur = 0, sum = 0, i = 0;
    #####: 1003:	uint arisize = 0;
        -: 1004:	unsigned char aribuf[16];
        -: 1005:
    #####: 1006:	if (sfDs.fpath[0] == 0x00)
branch  0 never executed
branch  1 never executed
        -: 1007:	{
    #####: 1008:		func_gtk_dialog_modal (0, window, "\n    대상파일이 선택되지 않았습니다.    \n");
call    0 never executed
        -: 1009:	}
        -: 1010:	else
        -: 1011:	{
    #####: 1012:		sprintf (message, 
        -: 1013:			"\n 아래 파일을 암호화 하시겠습니까?\n    [ %s ]    \n", sfDs.fpath);
        -: 1014:    
    #####: 1015:		if (func_gtk_dialog_modal(1, window, message) == GTK_RESPONSE_ACCEPT)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1016:		{
    #####: 1017:			int res = 0;
        -: 1018:
    #####: 1019:			fp = fopen (sfDs.fpath, "r");
call    0 never executed
    #####: 1020:			if (NULL == fp)
branch  0 never executed
branch  1 never executed
        -: 1021:			{
    #####: 1022:				printf("파일을 열수 없습니다.\n");
call    0 never executed
    #####: 1023:				return;
        -: 1024:			}
        -: 1025:
    #####: 1026:			fseek (fp, 0, SEEK_END);
call    0 never executed
    #####: 1027:			lSize = ftell (fp);
call    0 never executed
    #####: 1028:			rewind (fp);
call    0 never executed
        -: 1029:
    #####: 1030:			buff = (unsigned char *) malloc (sizeof (char) *lSize);
        -: 1031:
    #####: 1032:			while ((cur = fread (&buff[sum], sizeof (char), lSize - cur, fp)) > 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1033:			{
    #####: 1034:				sum += cur;
        -: 1035:			}
        -: 1036:
    #####: 1037:			if (sum != lSize)
branch  0 never executed
branch  1 never executed
        -: 1038:			{
    #####: 1039:				printf("파일을 읽을수 없습니다.\n");
call    0 never executed
        -: 1040:			}
        -: 1041:			
    #####: 1042:			while (arisize < sfDs.fsize)
branch  0 never executed
branch  1 never executed
        -: 1043:			{
    #####: 1044:				buff += i;
    #####: 1045:				memcpy (aribuf, buff, sizeof (aribuf));
    #####: 1046:				ARIA (aribuf);
call    0 never executed
    #####: 1047:				memcpy (buff, aribuf, sizeof (aribuf));
    #####: 1048:				memset (aribuf, 0, sizeof (aribuf));
    #####: 1049:				arisize += 16;
    #####: 1050:				i += 16;
        -: 1051:			}
    #####: 1052:			fclose (fp);
call    0 never executed
        -: 1053:
    #####: 1054:			fp = fopen (sfDs.fpath, "w+");
call    0 never executed
    #####: 1055:			fwrite (buff, lSize, 1, fp);
call    0 never executed
        -: 1056:
    #####: 1057:			for (int i = 0; i <= chk_fcnt; i++)
branch  0 never executed
branch  1 never executed
        -: 1058:			{
    #####: 1059:				res = strcmp (fname, fDs[i].fname);
        -: 1060:
    #####: 1061:				if (res == 0)
branch  0 never executed
branch  1 never executed
        -: 1062:				{
    #####: 1063:					strcpy (fDs[i].stat, "암호화");
    #####: 1064:					printf ("결과: [%d]번째 파일[%s]가 [%s] 되었습니다.\n", i, fDs[i].fname, fDs[i].stat);
call    0 never executed
        -: 1065:				}
        -: 1066:			}
        -: 1067:
    #####: 1068:			gtk_container_remove (GTK_CONTAINER (d_scrolledwindow), d_view);	// 다 지우기
call    0 never executed
call    1 never executed
        -: 1069:			//gtk_tree_store_remove(dtreestore, &diter);							// 선택한거만 지우기
        -: 1070:
    #####: 1071:			printf ("[UUID: %s], [파일이름: %s], [파일크기: %d], [파일상태: %s], [파일경로: %s]\n", sfDs.uuid, sfDs.fname, sfDs.fsize, sfDs.stat, sfDs.fpath);
call    0 never executed
        -: 1072:
    #####: 1073:			d_view = d_create_view_and_model();
call    0 never executed
    #####: 1074:			gtk_container_add (GTK_CONTAINER (d_scrolledwindow), d_view);
call    0 never executed
call    1 never executed
    #####: 1075:			gtk_widget_show_all ((GtkWidget *) d_scrolledwindow);
call    0 never executed
        -: 1076:
    #####: 1077:			strcpy (sfDs.stat, "암호화");
        -: 1078:
    #####: 1079:			fclose (fp);
call    0 never executed
        -: 1080:
    #####: 1081:			chk_df = 5;
    #####: 1082:			printf ("Close FILE\n");
call    0 never executed
    #####: 1083:			chk_fname[0] = 0; // 초기화 //
        -: 1084:		}
        -: 1085:		else
        -: 1086:		{
    #####: 1087:			printf ("취소 되었습니다.\n");
call    0 never executed
        -: 1088:		}
        -: 1089:	}
        -: 1090:
    #####: 1091:	return;
        -: 1092:}
        -: 1093:// end of func_ARIA (); //
        -: 1094:
        -: 1095:
        -: 1096:// main_window function #mf //
function m_detect_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1097:void m_detect_btn_clicked (GtkButton *m_detect_btn, gpointer *data)
        -: 1098:{
    #####: 1099:	gtk_widget_show (detect_window);
call    0 never executed
        -: 1100:	
    #####: 1101:	return;
        -: 1102:}
        -: 1103:
function m_setting_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1104:void m_setting_btn_clicked (GtkButton *m_setting_btn, gpointer *data)
        -: 1105:{
    #####: 1106:	gtk_widget_show (setting_window);
call    0 never executed
        -: 1107:
    #####: 1108:	return;
        -: 1109:}
        -: 1110:
function m_window_destroy called 0 returned 0% blocks executed 0%
    #####: 1111:void m_window_destroy()
        -: 1112:{
    #####: 1113:	gtk_main_quit();
call    0 never executed
        -: 1114:
    #####: 1115:	return;
        -: 1116:}
        -: 1117:/* end of main_window function */
        -: 1118:
        -: 1119:
        -: 1120:
        -: 1121:// detect_window function #df //
function d_detect_entry_activate called 0 returned 0% blocks executed 0%
    #####: 1122:void d_detect_entry_activate (GtkEntry *d_detect_entry, gpointer *data)
        -: 1123:{
    #####: 1124:	path = (gchar *)gtk_entry_get_text (d_detect_entry);
call    0 never executed
    #####: 1125:	g_print ("선택한 폴더 위치: %s\n", path);
call    0 never executed
        -: 1126:
    #####: 1127:	return;
        -: 1128:}
        -: 1129:
        -: 1130:
function d_folder_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1131:void d_folder_btn_clicked (GtkButton *d_folder_btn, gpointer *data)
        -: 1132:{
    #####: 1133:    filechooserdialog = gtk_file_chooser_dialog_new ("Open File", GTK_WINDOW (data), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, 
call    0 never executed
call    1 never executed
        -: 1134:			("_선택"), GTK_RESPONSE_ACCEPT, NULL);
        -: 1135:
    #####: 1136:    gtk_widget_show_all (filechooserdialog);
call    0 never executed
        -: 1137:    
    #####: 1138:	gint resp = gtk_dialog_run (GTK_DIALOG (filechooserdialog));
call    0 never executed
call    1 never executed
        -: 1139:
    #####: 1140:    if (resp == GTK_RESPONSE_ACCEPT)
branch  0 never executed
branch  1 never executed
        -: 1141:    {
    #####: 1142:		path = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (filechooserdialog));
call    0 never executed
call    1 never executed
        -: 1143:    } 
        -: 1144:
    #####: 1145:	gtk_entry_set_text (GTK_ENTRY (data), path);
call    0 never executed
call    1 never executed
        -: 1146:
        -: 1147:
    #####: 1148:	gtk_widget_destroy (filechooserdialog);
call    0 never executed
        -: 1149:
    #####: 1150:	g_print ("선택한 폴더 위치: %s\n", path);
call    0 never executed
        -: 1151:
    #####: 1152:	return;
        -: 1153:}
        -: 1154:
        -: 1155:	// treeview function #tf//
        -: 1156:enum
        -: 1157:{
        -: 1158:	d_treeview_num = 0,
        -: 1159:	d_treeview_filename,
        -: 1160:	d_treeview_jcnt,
        -: 1161:	d_treeview_dcnt,
        -: 1162:	d_treeview_fgcnt,
        -: 1163:	d_treeview_pcnt,
        -: 1164:	d_treeview_stat,
        -: 1165:	d_treeview_size,
        -: 1166:	d_treeview_fileloca,
        -: 1167:	NUM_COLS
        -: 1168:} ;
        -: 1169:
        -: 1170:gboolean
function d_view_selection_func called 0 returned 0% blocks executed 0%
    #####: 1171:d_view_selection_func 	(GtkTreeSelection *selection,
        -: 1172:							GtkTreeModel     *model,
        -: 1173:							GtkTreePath      *path,
        -: 1174:							gboolean          path_currently_selected,
        -: 1175:							gpointer          userdata)
        -: 1176:{
        -: 1177:	GtkTreeIter iter;
        -: 1178:	gchar *stat, *fpath;
        -: 1179:	uint fsize;
        -: 1180:	
    #####: 1181:	if (gtk_tree_model_get_iter (model, &iter, path))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1182:	{
    #####: 1183:		if (!path_currently_selected)
branch  0 never executed
branch  1 never executed
        -: 1184:		{
        -: 1185:			// set select data //
    #####: 1186:			gtk_tree_model_get (model, &iter, d_treeview_filename, 	&fname, -1);
call    0 never executed
    #####: 1187:			gtk_tree_model_get (model, &iter, d_treeview_size,			&fsize, -1);
call    0 never executed
    #####: 1188:			gtk_tree_model_get (model, &iter, d_treeview_stat,			&stat, -1);
call    0 never executed
    #####: 1189:			gtk_tree_model_get (model, &iter, d_treeview_fileloca,	&fpath, -1);
call    0 never executed
        -: 1190:
        -: 1191:			// input data in structure //
    #####: 1192:			strcpy (sfDs.fname, fname);
    #####: 1193:			sfDs.fsize = fsize;
    #####: 1194:			strcpy (sfDs.stat, stat);
    #####: 1195:			strcpy (sfDs.fpath, fpath);
        -: 1196:
    #####: 1197:			g_print ("파일위치: [%s], 파일크기: [%d] 선택.\n", sfDs.fpath, sfDs.fsize);
call    0 never executed
        -: 1198:
        -: 1199:		}
        -: 1200:		else
        -: 1201:		{
    #####: 1202:			g_print ("파일위치: [%s] 선택 해제.\n", sfDs.fpath);
call    0 never executed
        -: 1203:		}
        -: 1204:	}
        -: 1205:
    #####: 1206:	return TRUE; /* allow selection state to change */
        -: 1207:}
        -: 1208:
        -: 1209:
        -: 1210:static GtkTreeModel *
function d_create_and_fill_model called 0 returned 0% blocks executed 0%
    #####: 1211:d_create_and_fill_model (void)
        -: 1212:{
    #####: 1213:	dtreestore = gtk_tree_store_new (NUM_COLS, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_UINT,
call    0 never executed
        -: 1214:					G_TYPE_UINT, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_UINT, G_TYPE_STRING);
        -: 1215:
    #####: 1216:	for (int i = 0; i <= chk_fcnt; i++)
branch  0 never executed
branch  1 never executed
        -: 1217:	{
    #####: 1218:		gtk_tree_store_append (dtreestore, &diter, NULL);
call    0 never executed
    #####: 1219:		gtk_tree_store_set (dtreestore, &diter,
        -: 1220:					  d_treeview_num, i + 1,
    #####: 1221:					  d_treeview_filename,	fDs[i].fname,
        -: 1222:					  d_treeview_jcnt,	fDs[i].jcnt,
        -: 1223:					  d_treeview_dcnt,	fDs[i].dcnt,
        -: 1224:					  d_treeview_fgcnt,	fDs[i].fgcnt,
        -: 1225:					  d_treeview_pcnt,	fDs[i]. pcnt,
    #####: 1226:					  d_treeview_stat,	fDs[i].stat,
        -: 1227:					  d_treeview_size,	fDs[i].fsize,
    #####: 1228:					  d_treeview_fileloca,	fDs[i].fpath,
call    0 never executed
        -: 1229:					  -1);
        -: 1230:	}
        -: 1231:
    #####: 1232:	return GTK_TREE_MODEL (dtreestore);
call    0 never executed
        -: 1233:}
        -: 1234:
        -: 1235:static GtkWidget *
function d_create_view_and_model called 0 returned 0% blocks executed 0%
    #####: 1236:d_create_view_and_model (void)
        -: 1237:{
        -: 1238:	GtkTreeViewColumn	*col;
        -: 1239:	GtkCellRenderer		*renderer;
        -: 1240:	GtkWidget		*d_view;
        -: 1241:	GtkTreeModel		*model;
        -: 1242:	GtkTreeSelection	*selection;
        -: 1243:	
    #####: 1244:	d_view = gtk_tree_view_new();
call    0 never executed
        -: 1245:
        -: 1246:	// Column #컬럼명 //
    #####: 1247:	col = gtk_tree_view_column_new();
call    0 never executed
        -: 1248:
    #####: 1249:	gtk_tree_view_column_set_title (col, "번호");
call    0 never executed
        -: 1250:
        -: 1251:	// pack tree view column into tree view //
    #####: 1252:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
        -: 1253:
    #####: 1254:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
        -: 1255:
        -: 1256:	// pack cell renderer into tree view column //
    #####: 1257:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
        -: 1258:	
    #####: 1259:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_num);
call    0 never executed
        -: 1260:
        -: 1261:	// --- Column #파일 이름 --- //
    #####: 1262:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1263:	gtk_tree_view_column_set_title (col, "파일 이름");
call    0 never executed
    #####: 1264:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
    #####: 1265:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1266:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1267:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_filename);
call    0 never executed
        -: 1268:
        -: 1269:	// --- Column #주민번호 개수 --- //
    #####: 1270:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1271:	gtk_tree_view_column_set_title (col, "주민번호");
call    0 never executed
    #####: 1272:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
    #####: 1273:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1274:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1275:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_jcnt);
call    0 never executed
        -: 1276:
        -: 1277:	// --- Column #운전면허 개수 --- //
    #####: 1278:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1279:	gtk_tree_view_column_set_title (col, "운전면허");
call    0 never executed
    #####: 1280:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
    #####: 1281:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1282:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1283:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_dcnt);
call    0 never executed
        -: 1284:	
        -: 1285:	// --- Column #외국인등록번호 개수 --- //
    #####: 1286:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1287:	gtk_tree_view_column_set_title (col, "외국인등록");
call    0 never executed
    #####: 1288:	gtk_tree_view_append_column (GTK_TREE_VIEW(d_view), col);
call    0 never executed
call    1 never executed
    #####: 1289:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1290:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1291:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_fgcnt);
call    0 never executed
        -: 1292:	
        -: 1293:	// --- Column #여권번호 개수 --- //
    #####: 1294:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1295:	gtk_tree_view_column_set_title (col, "여권번호");
call    0 never executed
    #####: 1296:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
    #####: 1297:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1298:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1299:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_pcnt);
call    0 never executed
        -: 1300:
        -: 1301:	// --- Column #상태 --- //
    #####: 1302:	dcol = gtk_tree_view_column_new();
call    0 never executed
    #####: 1303:	gtk_tree_view_column_set_title (dcol, "상태");
call    0 never executed
    #####: 1304:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), dcol);
call    0 never executed
call    1 never executed
    #####: 1305:	drenderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1306:	gtk_tree_view_column_pack_start (dcol, drenderer, TRUE);
call    0 never executed
    #####: 1307:	gtk_tree_view_column_add_attribute (dcol, drenderer, "text", d_treeview_stat);
call    0 never executed
        -: 1308:	
        -: 1309:	// --- Column #파일 크기 --- //
    #####: 1310:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1311:	gtk_tree_view_column_set_title (col, "파일 크기");
call    0 never executed
    #####: 1312:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
    #####: 1313:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1314:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1315:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_size);
call    0 never executed
        -: 1316:	
        -: 1317:	// --- Column #파일 위치 --- //
    #####: 1318:	col = gtk_tree_view_column_new();
call    0 never executed
    #####: 1319:	gtk_tree_view_column_set_title (col, "파일 위치");
call    0 never executed
    #####: 1320:	gtk_tree_view_append_column (GTK_TREE_VIEW (d_view), col);
call    0 never executed
call    1 never executed
    #####: 1321:	renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1322:	gtk_tree_view_column_pack_start (col, renderer, TRUE);
call    0 never executed
    #####: 1323:	gtk_tree_view_column_add_attribute (col, renderer, "text", d_treeview_fileloca);
call    0 never executed
        -: 1324:	
    #####: 1325:	selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (d_view));
call    0 never executed
call    1 never executed
        -: 1326:	
    #####: 1327:	gtk_tree_selection_set_select_function (selection, d_view_selection_func, NULL, NULL);
call    0 never executed
        -: 1328:
        -: 1329:
        -: 1330:
    #####: 1331:	model = d_create_and_fill_model();
call    0 never executed
        -: 1332:
    #####: 1333:	gtk_tree_view_set_model (GTK_TREE_VIEW (d_view), model);
call    0 never executed
call    1 never executed
        -: 1334:
    #####: 1335:	g_object_unref (model); // destroy model automatically with view //
call    0 never executed
        -: 1336:
    #####: 1337:	gtk_tree_selection_set_mode(gtk_tree_view_get_selection (GTK_TREE_VIEW (d_view)),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1338:							  GTK_SELECTION_SINGLE);
        -: 1339:
    #####: 1340:	return d_view;
        -: 1341:}
        -: 1342:	/* end of treeview function */
        -: 1343:
        -: 1344:
function d_detect_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1345:void d_detect_btn_clicked (GtkButton *d_detect_btn, gpointer *data)
        -: 1346:{
    #####: 1347:	chk_df = 3;
    #####: 1348:	chk_fcnt = -1; 						// 파일개수 count 초기화
    #####: 1349:	memset (&fDs, 0, sizeof (fDs));		// 구조체 초기화
        -: 1350:	
    #####: 1351:	func_Detect (path);
call    0 never executed
    #####: 1352:	func_Send();
call    0 never executed
        -: 1353:
    #####: 1354:	gtk_container_remove (GTK_CONTAINER (d_scrolledwindow), d_view);	// 다 지우기
call    0 never executed
call    1 never executed
    #####: 1355:	d_view = d_create_view_and_model();
call    0 never executed
    #####: 1356:	gtk_container_add (GTK_CONTAINER (d_scrolledwindow), d_view);
call    0 never executed
call    1 never executed
    #####: 1357:	gtk_widget_show_all ((GtkWidget *) d_scrolledwindow);
call    0 never executed
        -: 1358:
    #####: 1359:	return;
        -: 1360:}
        -: 1361:
function d_option_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1362:void d_option_btn_clicked (GtkButton *d_option_btn, gpointer *data)
        -: 1363:{
    #####: 1364:	gtk_widget_show (setting_window);
call    0 never executed
        -: 1365:	
    #####: 1366:	return;
        -: 1367:}
        -: 1368:
function d_encrypt_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1369:void d_encrypt_btn_clicked (GtkButton *d_encrypt_btn, gpointer *data)//미구현//
        -: 1370:{
    #####: 1371:	func_ARIA();
call    0 never executed
        -: 1372:
    #####: 1373:	gtk_container_remove (GTK_CONTAINER (d_scrolledwindow), d_view);	// 다 지우기
call    0 never executed
call    1 never executed
        -: 1374:	//gtk_tree_store_remove(dtreestore, &diter);							// 선택한거만 지우기
        -: 1375:
    #####: 1376:	printf("[UUID: %s], [파일이름: %s], [파일크기: %d], [파일상태: %s], [파일경로: %s]\n", sfDs.uuid, sfDs.fname, sfDs.fsize, sfDs.stat, sfDs.fpath);
call    0 never executed
        -: 1377:
    #####: 1378:	d_view = d_create_view_and_model();
call    0 never executed
    #####: 1379:	gtk_container_add (GTK_CONTAINER (d_scrolledwindow), d_view);
call    0 never executed
call    1 never executed
    #####: 1380:	gtk_widget_show_all ((GtkWidget *) d_scrolledwindow);
call    0 never executed
        -: 1381:
    #####: 1382:	strcpy(sfDs.stat, "암호화");
    #####: 1383:	func_Send();
call    0 never executed
        -: 1384:
        -: 1385:
    #####: 1386:	return;
        -: 1387:}
        -: 1388:
function d_delete_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1389:void d_delete_btn_clicked (GtkButton *d_delete_btn, gpointer *data)
        -: 1390:{
        -: 1391:	char	message[1134];
        -: 1392:	
    #####: 1393:	if (sfDs.fpath[0] == 0x00)
branch  0 never executed
branch  1 never executed
        -: 1394:	{
    #####: 1395:		func_gtk_dialog_modal (0, window, "\n    대상파일이 선택되지 않았습니다.    \n");
call    0 never executed
        -: 1396:	}
        -: 1397:	else
        -: 1398:	{
    #####: 1399:		sprintf (message, 
        -: 1400:			"\n    삭제 후에 복구가 불가능 합니다.\n    아래 파일을 삭제하시겠습니까?\n    [ %s ]    \n", sfDs.fpath);
        -: 1401:    
    #####: 1402:		if (func_gtk_dialog_modal(1, window, message) == GTK_RESPONSE_ACCEPT)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1403:		{
    #####: 1404:			int res = 0;
        -: 1405:
    #####: 1406:			func_file_eraser (3);
call    0 never executed
        -: 1407:
    #####: 1408:			for (int i = 0; i <= chk_fcnt; i++)
branch  0 never executed
branch  1 never executed
        -: 1409:			{
    #####: 1410:				res = strcmp (fname, fDs[i].fname);
        -: 1411:
    #####: 1412:				if (res == 0)
branch  0 never executed
branch  1 never executed
        -: 1413:				{
    #####: 1414:					strcpy (fDs[i].stat, "삭제");
    #####: 1415:					printf ("결과: [%d]번째 파일[%s]가 [%s] 되었습니다.", i, fDs[i].fname, fDs[i].stat);
call    0 never executed
        -: 1416:				}
        -: 1417:			}
        -: 1418:
    #####: 1419:			gtk_container_remove (GTK_CONTAINER (d_scrolledwindow), d_view);	// 다 지우기
call    0 never executed
call    1 never executed
        -: 1420:			//gtk_tree_store_remove(dtreestore, &diter);				// 선택한거만 지우기
        -: 1421:
    #####: 1422:			printf ("[UUID: %s], [파일이름: %s], [파일크기: %d], [파일상태: %s], [파일경로: %s]\n", sfDs.uuid, sfDs.fname, sfDs.fsize, sfDs.stat, sfDs.fpath);
call    0 never executed
        -: 1423:
    #####: 1424:			d_view = d_create_view_and_model();
call    0 never executed
    #####: 1425:			gtk_container_add (GTK_CONTAINER (d_scrolledwindow), d_view);
call    0 never executed
call    1 never executed
    #####: 1426:			gtk_widget_show_all ((GtkWidget *) d_scrolledwindow);
call    0 never executed
        -: 1427:
    #####: 1428:			strcpy (sfDs.stat, "삭제");
    #####: 1429:			func_Send();
call    0 never executed
        -: 1430:		}
        -: 1431:		else
        -: 1432:		{
    #####: 1433:			printf("취소 되었습니다.\n");
call    0 never executed
        -: 1434:		}
        -: 1435:	}
        -: 1436:
    #####: 1437:	return;
        -: 1438:}
        -: 1439:
function d_close_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1440:void d_close_btn_clicked (GtkButton *d_close_btn, gpointer *data)
        -: 1441:{
    #####: 1442:	gtk_widget_hide (GTK_WIDGET (data));
call    0 never executed
call    1 never executed
        -: 1443:	
    #####: 1444:	return;
        -: 1445:}
        -: 1446:
function detect_window_destroy called 0 returned 0% blocks executed 0%
    #####: 1447:void detect_window_destroy (GtkWidget *detect_window, gpointer *data)
        -: 1448:{
    #####: 1449:	gtk_widget_destroy (GTK_WIDGET (detect_window));
call    0 never executed
call    1 never executed
        -: 1450:	
    #####: 1451:	return;
        -: 1452:}
        -: 1453:/* end of detect_window function */
        -: 1454:
        -: 1455:
        -: 1456:
        -: 1457:// enrollment_window function #ef //
        -: 1458:
function e_name_entry_activate called 0 returned 0% blocks executed 0%
    #####: 1459:void e_name_entry_activate (GtkEntry *e_name_entry, gpointer *data)
        -: 1460:{
    #####: 1461:	name = (gchar *)gtk_entry_get_text (e_name_entry);
call    0 never executed
    #####: 1462:	strcpy(uDs.uname, name);
    #####: 1463:	printf("%s\n", name);
call    0 never executed
        -: 1464:	
    #####: 1465:	return;
        -: 1466:}
        -: 1467:
function e_jobtitle_cbxtext_changed called 0 returned 0% blocks executed 0%
    #####: 1468:void e_jobtitle_cbxtext_changed	(GtkWidget *e_jobtitle_cbxtext, gpointer *data)
        -: 1469:{
    #####: 1470:	job = (gchar *)gtk_entry_get_text (GTK_ENTRY (gtk_bin_get_child (GTK_BIN (e_jobtitle_cbxtext))));
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####: 1471:	strcpy (uDs.ujob, job);
    #####: 1472:	printf ("%s\n", uDs.ujob);
call    0 never executed
        -: 1473:
    #####: 1474:	return;
        -: 1475:}
        -: 1476:
        -: 1477:
        -: 1478:enum
        -: 1479:{
        -: 1480:	e_treeview_col,
        -: 1481:	NUM_COL
        -: 1482:} ;
        -: 1483:
        -: 1484:gboolean
function e_view_selection_func called 0 returned 0% blocks executed 0%
    #####: 1485:e_view_selection_func 	(GtkTreeSelection *selection,
        -: 1486:							GtkTreeModel     *model,
        -: 1487:							GtkTreePath      *path,
        -: 1488:							gboolean          path_currently_selected,
        -: 1489:							gpointer          userdata)
        -: 1490:{
        -: 1491:	GtkTreeIter iter;
        -: 1492:
    #####: 1493:	if (gtk_tree_model_get_iter (model, &iter, path))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1494:	{
    #####: 1495:		gtk_tree_model_get (model, &iter, e_treeview_col, &vs_dept, -1);
call    0 never executed
        -: 1496:
    #####: 1497:		if (!path_currently_selected)
branch  0 never executed
branch  1 never executed
        -: 1498:		{
    #####: 1499:			g_print ("부서: [%s] 선택.\n", vs_dept);
call    0 never executed
        -: 1500:		}
        -: 1501:		else
        -: 1502:		{
    #####: 1503:			g_print ("부서: [%s] 선택 해제.\n", vs_dept);
call    0 never executed
        -: 1504:		}
        -: 1505:
    #####: 1506:		strcpy (uDs.udept, vs_dept);
        -: 1507:
    #####: 1508:		g_free (vs_dept);
call    0 never executed
        -: 1509:	}
        -: 1510:
    #####: 1511:	return TRUE; /* allow selection state to change */
        -: 1512:}
        -: 1513:
        -: 1514:static GtkTreeModel *
function e_create_and_fill_model called 0 returned 0% blocks executed 0%
    #####: 1515:e_create_and_fill_model (void)
        -: 1516:{
        -: 1517:	GtkTreeStore  *e_treestore;
        -: 1518:	GtkTreeIter    parent, child1;
        -: 1519:
    #####: 1520:	e_treestore = gtk_tree_store_new (NUM_COL, G_TYPE_STRING);
call    0 never executed
        -: 1521:
        -: 1522:	/*대표이사 0*/
    #####: 1523:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1524:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1525:					 e_treeview_col, "대표이사",
        -: 1526:					 -1);
        -: 1527:
        -: 1528:	/*임원실 1*/
    #####: 1529:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1530:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1531:					 e_treeview_col, "임원실",
        -: 1532:					 -1);
        -: 1533:
        -: 1534:	/*대전지사 2*/
    #####: 1535:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1536:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1537:					 e_treeview_col, "대전지사",
        -: 1538:					 -1);
        -: 1539:					 
        -: 1540:	/*경영혁신팀 3*/
    #####: 1541:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1542:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1543:					 e_treeview_col, "경영혁신팀",
        -: 1544:					 -1);
        -: 1545:
        -: 1546:	/*솔루션사업부 4*/
    #####: 1547:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1548:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1549:					 e_treeview_col, "솔루션사업부",
        -: 1550:					 -1);
        -: 1551:		/*솔루션사업부 영업팀 8*/
    #####: 1552:		gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1553:		gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1554:						 e_treeview_col, "솔루션사업부 영업팀",
        -: 1555:						 -1);
        -: 1556:		/*솔루션사업부 사업팀 9*/
    #####: 1557:		gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1558:		gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1559:						 e_treeview_col, "솔루션사업부 기술팀",
        -: 1560:						 -1);
        -: 1561:
        -: 1562:	/*보안인프라사업부 5*/
    #####: 1563:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1564:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1565:					 e_treeview_col, "보안인프라사업부",
        -: 1566:					 -1);
        -: 1567:		/*보안인프라사업부 영업팀 10*/
    #####: 1568:		gtk_tree_store_append (e_treestore, &child1, &parent);
call    0 never executed
    #####: 1569:		gtk_tree_store_set (e_treestore, &child1,
call    0 never executed
        -: 1570:						 e_treeview_col, "보안인프라사업부 영업팀",
        -: 1571:						 -1);
        -: 1572:		/*보안인프라사업부 기술팀 11*/
    #####: 1573:		gtk_tree_store_append (e_treestore, &child1, &parent);
call    0 never executed
    #####: 1574:		gtk_tree_store_set (e_treestore, &child1,
call    0 never executed
        -: 1575:						 e_treeview_col, "보안인프라사업부 기술팀",
        -: 1576:						 -1);
        -: 1577:
        -: 1578:	/*부설연구소 6*/
    #####: 1579:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1580:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1581:					 e_treeview_col, "부설연구소",
        -: 1582:					 -1);
        -: 1583:		/*부설연구소 개발1팀 12*/
    #####: 1584:		gtk_tree_store_append (e_treestore, &child1, &parent);
call    0 never executed
    #####: 1585:		gtk_tree_store_set (e_treestore, &child1,
call    0 never executed
        -: 1586:						 e_treeview_col, "부설연구소 개발1팀",
        -: 1587:						 -1);
        -: 1588:		/*부설연구소 개발2팀 13*/
    #####: 1589:		gtk_tree_store_append (e_treestore, &child1, &parent);
call    0 never executed
    #####: 1590:		gtk_tree_store_set (e_treestore, &child1,
call    0 never executed
        -: 1591:						 e_treeview_col, "부설연구소 개발2팀",
        -: 1592:						 -1);
        -: 1593:
        -: 1594:	/*특수사업부 7*/
    #####: 1595:	gtk_tree_store_append (e_treestore, &parent, e_treeview_col);
call    0 never executed
    #####: 1596:	gtk_tree_store_set (e_treestore, &parent,
call    0 never executed
        -: 1597:					 e_treeview_col, "특수사업부",
        -: 1598:					 -1);
        -: 1599:		/*특수사업부 자사품 TF팀 14*/
    #####: 1600:		gtk_tree_store_append (e_treestore, &child1, &parent);
call    0 never executed
    #####: 1601:		gtk_tree_store_set (e_treestore, &child1,
call    0 never executed
        -: 1602:						 e_treeview_col, "특수사업부 자사품 TF팀",
        -: 1603:						 -1);
        -: 1604:		/*특수사업부 컨설팅팀 15*/
    #####: 1605:		gtk_tree_store_append (e_treestore, &child1, &parent);
call    0 never executed
    #####: 1606:		gtk_tree_store_set (e_treestore, &child1,
call    0 never executed
        -: 1607:						 e_treeview_col, "특수사업부 컨설팅팀",
        -: 1608:						 -1);
        -: 1609:                     
    #####: 1610:	return GTK_TREE_MODEL (e_treestore);
call    0 never executed
        -: 1611:}
        -: 1612:
        -: 1613:static GtkWidget *
function e_create_view_and_model called 0 returned 0% blocks executed 0%
    #####: 1614:e_create_view_and_model (void)
        -: 1615:{
        -: 1616:	GtkTreeViewColumn	*e_col;
        -: 1617:	GtkCellRenderer		*e_renderer;
        -: 1618:	GtkWidget		*e_view;
        -: 1619:	GtkTreeModel		*e_model;
        -: 1620:	GtkTreeSelection	*e_selection;
        -: 1621:	
    #####: 1622:	e_view = gtk_tree_view_new();
call    0 never executed
        -: 1623:
        -: 1624:	// Column #부서 //
    #####: 1625:	e_col = gtk_tree_view_column_new();
call    0 never executed
        -: 1626:
    #####: 1627:	gtk_tree_view_column_set_title (e_col, "(주)조은아이앤에스 조직도");
call    0 never executed
        -: 1628:
    #####: 1629:	gtk_tree_view_append_column (GTK_TREE_VIEW (e_view), e_col);
call    0 never executed
call    1 never executed
    #####: 1630:	e_renderer = gtk_cell_renderer_text_new();
call    0 never executed
    #####: 1631:	gtk_tree_view_column_pack_start (e_col, e_renderer, TRUE);
call    0 never executed
        -: 1632:	
    #####: 1633:	gtk_tree_view_column_add_attribute(e_col, e_renderer, "text", e_treeview_col);
call    0 never executed
        -: 1634:	
    #####: 1635:	e_selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (e_view));
call    0 never executed
call    1 never executed
        -: 1636:	
    #####: 1637:	gtk_tree_selection_set_select_function (e_selection, e_view_selection_func, NULL, NULL);
call    0 never executed
        -: 1638:	
    #####: 1639:	e_model = e_create_and_fill_model();
call    0 never executed
        -: 1640:
    #####: 1641:	gtk_tree_view_set_model (GTK_TREE_VIEW (e_view), e_model);
call    0 never executed
call    1 never executed
        -: 1642:
    #####: 1643:	g_object_unref (e_model); // destroy model automatically with view //
call    0 never executed
        -: 1644:	
    #####: 1645:	gtk_tree_selection_set_mode (gtk_tree_view_get_selection (GTK_TREE_VIEW (e_view)),
call    0 never executed
call    1 never executed
call    2 never executed
        -: 1646:                              GTK_SELECTION_SINGLE);
        -: 1647:
    #####: 1648:	return e_view;
        -: 1649:}
        -: 1650:
function dept_ok_btn_clicked_w called 0 returned 0% blocks executed 0%
    #####: 1651:void dept_ok_btn_clicked_w (GtkButton *dept_ok_btn,	gpointer *data)
        -: 1652:{
    #####: 1653:	gtk_widget_hide (department_window);
call    0 never executed
    #####: 1654:}
        -: 1655:
function dept_ok_btn_clicked_e called 0 returned 0% blocks executed 0%
    #####: 1656:void dept_ok_btn_clicked_e (GtkButton *dept_ok_btn,	gpointer *data)
        -: 1657:{
    #####: 1658:	gtk_entry_set_text (GTK_ENTRY(data), uDs.udept);
call    0 never executed
call    1 never executed
        -: 1659:
    #####: 1660:	return;
        -: 1661:}
        -: 1662:
function dept_close_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1663:void dept_close_btn_clicked (GtkButton *dept_close_btn,	gpointer *data)
        -: 1664:{
    #####: 1665:	gtk_widget_hide (department_window);
call    0 never executed
    #####: 1666:}
        -: 1667:
function e_department_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1668:void e_department_btn_clicked (GtkButton *e_department_btn,	gpointer *data)
        -: 1669:{
        -: 1670:	GtkWidget *e_view;
        -: 1671:	
    #####: 1672:	e_view = e_create_view_and_model();
call    0 never executed
    #####: 1673:	gtk_container_add (GTK_CONTAINER (dept_scrolledwindow), e_view);
call    0 never executed
call    1 never executed
    #####: 1674:	gtk_widget_show_all ((GtkWidget *) department_window);
call    0 never executed
    #####: 1675:}
        -: 1676:
function e_enroll_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1677:void e_enroll_btn_clicked (GtkButton *e_enroll_btn, gpointer *data)
        -: 1678:{
    #####: 1679:	char *usrinfostr = malloc (sizeof (char) * 10);
        -: 1680:
    #####: 1681:	chk_df = 2;
        -: 1682:
    #####: 1683:	sprintf (usrinfostr, "%s %s", uDs.uname, uDs.ujob);
        -: 1684:
    #####: 1685:	gtk_widget_hide (enrollment_window);
call    0 never executed
        -: 1686:
    #####: 1687:	gtk_label_set_text (GTK_LABEL (m_userinfo_label), usrinfostr);
call    0 never executed
call    1 never executed
    #####: 1688:	gtk_widget_show (main_window);
call    0 never executed
        -: 1689:
    #####: 1690:	printf("부서: %s 사용자: %s, 직급: %s \n", uDs.udept, uDs.uname, uDs.ujob);
call    0 never executed
        -: 1691:	//printf("%s\n", usrinfostr);
    #####: 1692:	func_Send();
call    0 never executed
        -: 1693:
    #####: 1694:	gtk_main();
call    0 never executed
        -: 1695:	
    #####: 1696:	return;
        -: 1697:}
        -: 1698:/* end of enrollment_window */
        -: 1699:
        -: 1700:
        -: 1701:// setting_window function #sf //
function s_ip_entry_activate called 0 returned 0% blocks executed 0%
    #####: 1702:void s_ip_entry_activate (GtkEntry  *s_ip_entry,	gpointer *data)
        -: 1703:{
        -: 1704:	char *hostname;
    #####: 1705:	hostname = (gchar *) gtk_entry_get_text (s_ip_entry);
call    0 never executed
    #####: 1706:	g_print ("HOST NAME: %s\n", hostname);
call    0 never executed
        -: 1707:
    #####: 1708:	return;
        -: 1709:}
        -: 1710:
function s_port_entry_activate called 0 returned 0% blocks executed 0%
    #####: 1711:void s_port_entry_activate (GtkEntry  *s_port_entry,	gpointer *data)
        -: 1712:{
        -: 1713:	char *port;
    #####: 1714:	port = (gchar *) gtk_entry_get_text (s_port_entry);
call    0 never executed
    #####: 1715:	g_print("PORT: %s\n", port);
call    0 never executed
        -: 1716:
    #####: 1717:	return;
        -: 1718:}
        -: 1719:
function s_detect_entry_activate called 0 returned 0% blocks executed 0%
    #####: 1720:void s_detect_entry_activate	(GtkEntry  *s_detect_entry,	gpointer *data)
        -: 1721:{
    #####: 1722:	path = (gchar *)gtk_entry_get_text(s_detect_entry);
call    0 never executed
    #####: 1723:	g_print("선택한 디폴트 폴더 위치: %s\n", dpath);
call    0 never executed
        -: 1724:
    #####: 1725:	return;
        -: 1726:}
        -: 1727:
function s_folder_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1728:void s_folder_btn_clicked (GtkButton *s_folder_btn,	gpointer *data)
        -: 1729:{
    #####: 1730:    filechooserdialog = gtk_file_chooser_dialog_new ("Open File", GTK_WINDOW (data), GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER, 
call    0 never executed
call    1 never executed
        -: 1731:			("_선택"), GTK_RESPONSE_ACCEPT, NULL);
        -: 1732:
    #####: 1733:    gtk_widget_show_all (filechooserdialog);
call    0 never executed
        -: 1734:    
    #####: 1735:	gint resp = gtk_dialog_run (GTK_DIALOG (filechooserdialog));
call    0 never executed
call    1 never executed
        -: 1736:
    #####: 1737:    if (resp == GTK_RESPONSE_ACCEPT)
branch  0 never executed
branch  1 never executed
        -: 1738:    {
    #####: 1739:	gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (filechooserdialog));
call    0 never executed
call    1 never executed
        -: 1740:    } 
    #####: 1741:	dpath = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (filechooserdialog));
call    0 never executed
call    1 never executed
        -: 1742:
    #####: 1743:	gtk_entry_set_text (GTK_ENTRY (data), dpath);
call    0 never executed
call    1 never executed
        -: 1744:
        -: 1745:
    #####: 1746:	gtk_widget_destroy (filechooserdialog);
call    0 never executed
        -: 1747:
    #####: 1748:	g_print ("선택한 디폴트 폴더 위치: %s\n", dpath);
call    0 never executed
        -: 1749:
    #####: 1750:	return;
        -: 1751:}
        -: 1752:
function s_usrchg_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1753:void s_usrchg_btn_clicked (GtkButton *s_usrchg_btn,	gpointer *data)
        -: 1754:{
    #####: 1755:	gtk_widget_show (enrollment_window);
call    0 never executed
    #####: 1756:	return;
        -: 1757:}
        -: 1758:
        -: 1759:
function s_ok_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1760:void s_ok_btn_clicked (GtkButton *s_ok_btn,		gpointer *data)
        -: 1761:{
    #####: 1762:	gtk_widget_hide (GTK_WIDGET(data));
call    0 never executed
call    1 never executed
        -: 1763:
    #####: 1764:	return;
        -: 1765:}
        -: 1766:
function s_cloese_btn_clicked called 0 returned 0% blocks executed 0%
    #####: 1767:void s_cloese_btn_clicked (GtkButton *setting_window, gpointer *data)
        -: 1768:{
    #####: 1769:	gtk_widget_hide (GTK_WIDGET(data));
call    0 never executed
call    1 never executed
        -: 1770:	
    #####: 1771:	return;
        -: 1772:}
        -: 1773:/* end of setting_window function */
        -: 1774:
        -: 1775:
        -: 1776:
        -: 1777:// main #main //
function main called 0 returned 0% blocks executed 0%
    #####: 1778:int main (int argc, char *argv[])
        -: 1779:{
        -: 1780:	int chkini;
        -: 1781:	
    #####: 1782:	gtk_init(&argc, &argv);
call    0 never executed
        -: 1783:
    #####: 1784:	builder = gtk_builder_new();
call    0 never executed
    #####: 1785:	gtk_builder_add_from_file(builder, "main.glade", NULL);
call    0 never executed
        -: 1786:
    #####: 1787:	main_window		= GTK_WIDGET (gtk_builder_get_object (builder, "main_window"));
call    0 never executed
call    1 never executed
    #####: 1788:	enrollment_window	= GTK_WIDGET (gtk_builder_get_object (builder, "enrollment_window"));
call    0 never executed
call    1 never executed
    #####: 1789:	department_window	= GTK_WIDGET (gtk_builder_get_object (builder, "department_window"));
call    0 never executed
call    1 never executed
    #####: 1790:	detect_window		= GTK_WIDGET (gtk_builder_get_object (builder, "detect_window"));
call    0 never executed
call    1 never executed
    #####: 1791:	setting_window		= GTK_WIDGET (gtk_builder_get_object (builder, "setting_window"));
call    0 never executed
call    1 never executed
    #####: 1792:	d_progressbar 		= GTK_WIDGET (gtk_builder_get_object (builder, "d_progressbar"));
call    0 never executed
call    1 never executed
    #####: 1793:	d_scrolledwindow	= GTK_SCROLLED_WINDOW (gtk_builder_get_object (builder, "d_scrolledwindow"));
call    0 never executed
call    1 never executed
    #####: 1794:	dept_scrolledwindow	= GTK_SCROLLED_WINDOW (gtk_builder_get_object (builder, "dept_scrolledwindow"));
call    0 never executed
call    1 never executed
    #####: 1795:	m_userinfo_label = GTK_WIDGET (gtk_builder_get_object (builder, "m_userinfo_label"));
call    0 never executed
call    1 never executed
    #####: 1796:	gtk_window_set_position (GTK_WINDOW (detect_window), GTK_WIN_POS_CENTER);
call    0 never executed
call    1 never executed
        -: 1797:
        -: 1798:	// 닫기x 버튼을 hide로 바꾸기, -버튼 활성화 하고 싶으면 glade에서 modal 해제 //
    #####: 1799:	g_signal_connect (detect_window, "delete_event", G_CALLBACK (gtk_widget_hide_on_delete), NULL);
call    0 never executed
    #####: 1800:	g_signal_connect (setting_window, "delete_event", G_CALLBACK (gtk_widget_hide_on_delete), NULL);
call    0 never executed
    #####: 1801:	g_signal_connect (enrollment_window, "delete_event", G_CALLBACK (gtk_widget_hide_on_delete), NULL);
call    0 never executed
        -: 1802:
    #####: 1803:	gtk_builder_connect_signals (builder, NULL);
call    0 never executed
        -: 1804:
    #####: 1805:	func_Uuid();			// 사용자 UUID	//
call    0 never executed
        -: 1806:	
        -: 1807:	// Ini File Check //
    #####: 1808:	chkini = func_ParseIni ("plover.ini");
call    0 never executed
    #####: 1809:	if (chkini != 0)
branch  0 never executed
branch  1 never executed
        -: 1810:	{
    #####: 1811:		func_CreateIni();
call    0 never executed
    #####: 1812:		printf ("ini 파일 생성!\n");
call    0 never executed
    #####: 1813:		chkini = func_ParseIni ("plover.ini");
call    0 never executed
        -: 1814:    }
        -: 1815:
    #####: 1816:	func_SetRabbit();	// 서버와 연결	//
call    0 never executed
    #####: 1817:	func_VerChk();		// 버전 확인	//
call    0 never executed
    #####: 1818:	func_UsrChk();		// 사용자 확인	//
call    0 never executed
        -: 1819:
    #####: 1820:	g_object_unref(builder);
call    0 never executed
        -: 1821:
    #####: 1822:	gtk_widget_show(window);
call    0 never executed
        -: 1823:
    #####: 1824:	return 0;
        -: 1825:}
