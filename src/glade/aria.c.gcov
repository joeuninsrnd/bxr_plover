        -:    0:Source:aria.c
        -:    0:Graph:main.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * ANSI-C code for ARIA version 1.0
        -:    5: *
        -:    6: * Reference code for ARIA
        -:    7: *
        -:    8: * 2005. 01. 17.
        -:    9: * 
        -:   10: * Note:
        -:   11: *    - Now we use the following interface:
        -:   12: *      void Crypt(const Byte *plainText, int numberOfRounds, const Byte *roundKeys, Byte *cipherText);
        -:   13: *      int EncKeySetup(const Byte *masterKey, Byte *roundKeys, int keyBits);
        -:   14: *      int DecKeySetup(const Byte *masterKey, Byte *roundKeys, int keyBits);
        -:   15: *    - EncKeySetup() and DecKeySetup() return the number of rounds.
        -:   16: *
        -:   17: */
        -:   18:
        -:   19:#include <stdio.h>
        -:   20:#include <stdlib.h>
        -:   21:
        -:   22:typedef unsigned char Byte;
        -:   23:
        -:   24:const Byte S[4][256] = {
        -:   25:	// S-box type 1
        -:   26:{
        -:   27:  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        -:   28:  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        -:   29:  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        -:   30:  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        -:   31:  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        -:   32:  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        -:   33:  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        -:   34:  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        -:   35:  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        -:   36:  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        -:   37:  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        -:   38:  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        -:   39:  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        -:   40:  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        -:   41:  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        -:   42:  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16},
        -:   43:  // S-box type 2
        -:   44:{
        -:   45:  0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1,
        -:   46:  0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1,
        -:   47:  0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb,
        -:   48:  0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb,
        -:   49:  0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd,
        -:   50:  0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53,
        -:   51:  0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1,
        -:   52:  0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40,
        -:   53:  0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc,
        -:   54:  0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5,
        -:   55:  0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43,
        -:   56:  0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8,
        -:   57:  0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda,
        -:   58:  0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c,
        -:   59:  0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d,
        -:   60:  0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81},
        -:   61:  // inverse of S-box type 1
        -:   62:{
        -:   63:  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        -:   64:  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        -:   65:  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        -:   66:  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        -:   67:  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        -:   68:  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        -:   69:  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        -:   70:  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        -:   71:  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        -:   72:  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        -:   73:  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        -:   74:  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        -:   75:  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        -:   76:  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        -:   77:  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        -:   78:  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d},
        -:   79:  // inverse of S-box type 2
        -:   80:{
        -:   81:  0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62, 0x3c,
        -:   82:  0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20, 0xc4, 0x8d,
        -:   83:  0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4, 0x40, 0x1a, 0x4d,
        -:   84:  0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98, 0x0c, 0xf4, 0x9b, 0xed,
        -:   85:  0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06, 0xc3, 0x35, 0x0d, 0x01, 0x8b,
        -:   86:  0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e, 0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce,
        -:   87:  0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4, 0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9,
        -:   88:  0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19, 0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41,
        -:   89:  0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe, 0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a,
        -:   90:  0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7,
        -:   91:  0x84, 0xe9, 0xd2, 0xba, 0x5d, 0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc,
        -:   92:  0xeb, 0x6f, 0xd5, 0xf6, 0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5,
        -:   93:  0x91, 0x1f, 0x05, 0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45,
        -:   94:  0xb2, 0x0f, 0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d,
        -:   95:  0xf2, 0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3,
        -:   96:  0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac, 0x60}
        -:   97:};
        -:   98:// constants used in the round key generation
        -:   99:const Byte KRK[3][16] = {
        -:  100:  {0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0}, 
        -:  101:  {0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0}, 
        -:  102:  {0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e}
        -:  103:};
        -:  104:
        -:  105:// Diffusion Layer
    #####:  106:void DL (const Byte *i, Byte *o)
        -:  107:{
        -:  108:	Byte T;
        -:  109:  
    #####:  110:	T = i[ 3] ^ i[ 4] ^ i[ 9] ^ i[14];
    #####:  111:	o[ 0] = i[ 6] ^ i[ 8] ^ i[13] ^ T;
    #####:  112:	o[ 5] = i[ 1] ^ i[10] ^ i[15] ^ T;
    #####:  113:	o[11] = i[ 2] ^ i[ 7] ^ i[12] ^ T;
    #####:  114:	o[14] = i[ 0] ^ i[ 5] ^ i[11] ^ T;
    #####:  115:	T = i[ 2] ^ i[ 5] ^ i[ 8] ^ i[15];
    #####:  116:	o[ 1] = i[ 7] ^ i[ 9] ^ i[12] ^ T;
    #####:  117:	o[ 4] = i[ 0] ^ i[11] ^ i[14] ^ T;
    #####:  118:	o[10] = i[ 3] ^ i[ 6] ^ i[13] ^ T;
    #####:  119:	o[15] = i[ 1] ^ i[ 4] ^ i[10] ^ T;
    #####:  120:	T = i[ 1] ^ i[ 6] ^ i[11] ^ i[12];
    #####:  121:	o[ 2] = i[ 4] ^ i[10] ^ i[15] ^ T;
    #####:  122:	o[ 7] = i[ 3] ^ i[ 8] ^ i[13] ^ T;
    #####:  123:	o[ 9] = i[ 0] ^ i[ 5] ^ i[14] ^ T;
    #####:  124:	o[12] = i[ 2] ^ i[ 7] ^ i[ 9] ^ T;
    #####:  125:	T = i[ 0] ^ i[ 7] ^ i[10] ^ i[13];
    #####:  126:	o[ 3] = i[ 5] ^ i[11] ^ i[14] ^ T;
    #####:  127:	o[ 6] = i[ 2] ^ i[ 9] ^ i[12] ^ T;
    #####:  128:	o[ 8] = i[ 1] ^ i[ 4] ^ i[15] ^ T;
    #####:  129:	o[13] = i[ 3] ^ i[ 6] ^ i[ 8] ^ T;
    #####:  130:}
        -:  131:// Right-rotate 128 bit source string s by n bits and XOR it to target string t
    #####:  132:void RotXOR (const Byte *s, int n, Byte *t)
        -:  133:{
        -:  134:	int i, q;
        -:  135:  
    #####:  136:	q = n/8; n %= 8;
    #####:  137:	for (i = 0; i < 16; i++) {
    #####:  138:		t[(q+i) % 16] ^= (s[i] >> n);
    #####:  139:		if (n != 0) t[(q+i+1) % 16] ^= (s[i] << (8-n));
        -:  140:	}
    #####:  141:}
        -:  142:
        -:  143:void printBlock(Byte *b);
        -:  144:
        -:  145:// Encryption round key generation rountine
        -:  146:// w0 : master key, e : encryption round keys
    #####:  147:int EncKeySetup(const Byte *w0, Byte *e, int keyBits) {
    #####:  148:	int  i, R=(keyBits+256)/32, q;
        -:  149:	Byte t[16], w1[16], w2[16], w3[16];
        -:  150:  
    #####:  151:	q = (keyBits - 128) / 64;
    #####:  152:	for (i = 0; i < 16; i++) t[i] = S[     i  % 4][KRK[q][i   ] ^ w0[i]];
    #####:  153:	DL (t, w1);
    #####:  154:	if (R==14)
    #####:  155:		for (i = 0; i <  8; i++) w1[i] ^= w0[16+i];
    #####:  156:	else if (R==16)
    #####:  157:		for (i = 0; i < 16; i++) w1[i] ^= w0[16+i];
        -:  158:  
    #####:  159:	q = (q==2)? 0 : (q+1);
    #####:  160:	for (i = 0; i < 16; i++) t[i] = S[(2 + i) % 4][KRK[q][i] ^ w1[i]];
    #####:  161:	DL (t, w2);
    #####:  162:	for (i = 0; i < 16; i++) w2[i] ^= w0[i];
        -:  163:  
    #####:  164:	q = (q==2)? 0 : (q+1);
    #####:  165:	for (i = 0; i < 16; i++) t[i] = S[     i  % 4][KRK[q][i] ^ w2[i]];
    #####:  166:	DL (t, w3);
    #####:  167:	for (i = 0; i < 16; i++) w3[i] ^= w1[i];
        -:  168:  
    #####:  169:	for (i = 0; i < 16*(R+1); i++) e[i] = 0;
        -:  170:  
    #####:  171:	RotXOR (w0, 0, e      ); RotXOR (w1,  19, e      );
    #####:  172:	RotXOR (w1, 0, e +  16); RotXOR (w2,  19, e +  16);
    #####:  173:	RotXOR (w2, 0, e +  32); RotXOR (w3,  19, e +  32);
    #####:  174:	RotXOR (w3, 0, e +  48); RotXOR (w0,  19, e +  48);
    #####:  175:	RotXOR (w0, 0, e +  64); RotXOR (w1,  31, e +  64);
    #####:  176:	RotXOR (w1, 0, e +  80); RotXOR (w2,  31, e +  80);
    #####:  177:	RotXOR (w2, 0, e +  96); RotXOR (w3,  31, e +  96);
    #####:  178:	RotXOR (w3, 0, e + 112); RotXOR (w0,  31, e + 112);
    #####:  179:	RotXOR (w0, 0, e + 128); RotXOR (w1,  67, e + 128);
    #####:  180:	RotXOR (w1, 0, e + 144); RotXOR (w2,  67, e + 144);
    #####:  181:	RotXOR (w2, 0, e + 160); RotXOR (w3,  67, e + 160);
    #####:  182:	RotXOR (w3, 0, e + 176); RotXOR (w0,  67, e + 176);
    #####:  183:	RotXOR (w0, 0, e + 192); RotXOR (w1,  97, e + 192);
    #####:  184:	if (R > 12) {
    #####:  185:		RotXOR (w1, 0, e + 208); RotXOR (w2,  97, e + 208);
    #####:  186:		RotXOR (w2, 0, e + 224); RotXOR (w3,  97, e + 224);
        -:  187:	}
    #####:  188:	if (R > 14) {
    #####:  189:		RotXOR (w3, 0, e + 240); RotXOR (w0,  97, e + 240);
    #####:  190:		RotXOR (w0, 0, e + 256); RotXOR (w1, 109, e + 256);
        -:  191:	}
    #####:  192:	return R;
        -:  193:}
        -:  194:// Decryption round key generation rountine
        -:  195:// w0 : maskter key, d : decryption round keys
    #####:  196:int DecKeySetup(const Byte *w0, Byte *d, int keyBits) {
        -:  197:	int  i, j, R;
        -:  198:	Byte t[16];
        -:  199:  
    #####:  200:	R=EncKeySetup(w0, d, keyBits);
    #####:  201:	for (j = 0; j < 16; j++){
    #####:  202:		t[j] = d[j];
    #####:  203:		d[j] = d[16*R + j];
    #####:  204:		d[16*R + j] = t[j];
        -:  205:	}
    #####:  206:	for (i = 1; i <= R/2; i++){
    #####:  207:		DL (d + i*16, t);
    #####:  208:		DL (d + (R-i)*16, d + i*16);
    #####:  209:		for (j = 0; j < 16; j++) d[(R-i)*16 + j] = t[j];
        -:  210:	}
    #####:  211:	return R;
        -:  212:}
        -:  213:// Encryption and decryption rountine
        -:  214:// p: plain text, e: round keys, c: ciphertext
    #####:  215:void Crypt(const Byte *p, int R, const Byte *e, Byte *c)
        -:  216:{
        -:  217:	int i, j;
        -:  218:	Byte t[16];
        -:  219:  
    #####:  220:	for (j = 0; j < 16; j++) c[j] = p[j];
    #####:  221:	for (i = 0; i < R/2; i++)
        -:  222:	{
    #####:  223:		for (j = 0; j < 16; j++) t[j] = S[     j  % 4][e[j] ^ c[j]];
    #####:  224:		DL(t, c); e += 16;
    #####:  225:		for (j = 0; j < 16; j++) t[j] = S[(2 + j) % 4][e[j] ^ c[j]];
    #####:  226:		DL(t, c); e += 16;
        -:  227:	}
    #####:  228:	DL(c, t);
    #####:  229:	for (j = 0; j < 16; j++) c[j] = e[j] ^ t[j];
    #####:  230:}
        -:  231:
    #####:  232:void printBlockOfLength(Byte *b, int len) {
        -:  233:	int i;
        -:  234:  
    #####:  235:	for (i=0; i<len; i++, b++) {
    #####:  236:		printf("%02x", *b);
    #####:  237:		if (i%4==3 && i<len-1) printf(" ");
        -:  238:	}
    #####:  239:}
        -:  240:
    #####:  241:void printBlock(Byte *b) {
    #####:  242:  printBlockOfLength(b, 16);
    #####:  243:}
        -:  244:
    #####:  245:char ARIA (Byte *p) {
        -:  246:	Byte rk[16*17], c[16], mk[32];
        -:  247:	int i;
        -:  248:
    #####:  249:	for (i=0; i<16; i++)
    #####:  250:		mk[i]=i*0x11;
    #####:  251:	for (i=16; i<24; i++)
    #####:  252:		mk[i]=(i-16)*0x11;
        -:  253:  
    #####:  254:	Crypt(p, EncKeySetup(mk, rk, 192), rk, c);
        -:  255:
    #####:  256:	return *p;
        -:  257:}
        -:  258:
        -:  259:/*
        -:  260:#include <stdio.h>
        -:  261:#include <stdlib.h>
        -:  262:
        -:  263:typedef unsigned char Byte;
        -:  264:
        -:  265:const Byte S[4][256] = {
        -:  266:	// S-box type 1
        -:  267:{
        -:  268:  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
        -:  269:  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
        -:  270:  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
        -:  271:  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
        -:  272:  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
        -:  273:  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
        -:  274:  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
        -:  275:  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
        -:  276:  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
        -:  277:  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
        -:  278:  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
        -:  279:  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
        -:  280:  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
        -:  281:  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
        -:  282:  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        -:  283:  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16},
        -:  284:  // S-box type 2
        -:  285:{
        -:  286:  0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b, 0xd1,
        -:  287:  0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19, 0x59, 0xc1,
        -:  288:  0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63, 0xdf, 0xe7, 0xbb,
        -:  289:  0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa, 0x0f, 0xee, 0x10, 0xeb,
        -:  290:  0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8, 0x95, 0xf9, 0x2f, 0xce, 0xcd,
        -:  291:  0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb, 0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53,
        -:  292:  0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01, 0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1,
        -:  293:  0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26, 0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40,
        -:  294:  0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84, 0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc,
        -:  295:  0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3, 0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5,
        -:  296:  0x15, 0xdd, 0xfd, 0x17, 0xa9, 0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43,
        -:  297:  0xa7, 0xe1, 0xd0, 0xf5, 0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8,
        -:  298:  0x30, 0xc6, 0x51, 0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda,
        -:  299:  0xe6, 0x75, 0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c,
        -:  300:  0x90, 0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d,
        -:  301:  0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5, 0x81},
        -:  302:  // inverse of S-box type 1
        -:  303:{
        -:  304:  0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        -:  305:  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        -:  306:  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        -:  307:  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        -:  308:  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        -:  309:  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        -:  310:  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        -:  311:  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        -:  312:  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        -:  313:  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        -:  314:  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        -:  315:  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        -:  316:  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        -:  317:  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        -:  318:  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        -:  319:  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d},
        -:  320:  // inverse of S-box type 2
        -:  321:{
        -:  322:  0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62, 0x3c,
        -:  323:  0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20, 0xc4, 0x8d,
        -:  324:  0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4, 0x40, 0x1a, 0x4d,
        -:  325:  0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98, 0x0c, 0xf4, 0x9b, 0xed,
        -:  326:  0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06, 0xc3, 0x35, 0x0d, 0x01, 0x8b,
        -:  327:  0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e, 0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce,
        -:  328:  0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4, 0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9,
        -:  329:  0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19, 0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41,
        -:  330:  0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe, 0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a,
        -:  331:  0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b, 0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7,
        -:  332:  0x84, 0xe9, 0xd2, 0xba, 0x5d, 0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc,
        -:  333:  0xeb, 0x6f, 0xd5, 0xf6, 0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5,
        -:  334:  0x91, 0x1f, 0x05, 0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45,
        -:  335:  0xb2, 0x0f, 0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d,
        -:  336:  0xf2, 0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3,
        -:  337:  0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac, 0x60}
        -:  338:};
        -:  339:// constants used in the round key generation
        -:  340:const Byte KRK[3][16] = {
        -:  341:  {0x51, 0x7c, 0xc1, 0xb7, 0x27, 0x22, 0x0a, 0x94, 0xfe, 0x13, 0xab, 0xe8, 0xfa, 0x9a, 0x6e, 0xe0}, 
        -:  342:  {0x6d, 0xb1, 0x4a, 0xcc, 0x9e, 0x21, 0xc8, 0x20, 0xff, 0x28, 0xb1, 0xd5, 0xef, 0x5d, 0xe2, 0xb0}, 
        -:  343:  {0xdb, 0x92, 0x37, 0x1d, 0x21, 0x26, 0xe9, 0x70, 0x03, 0x24, 0x97, 0x75, 0x04, 0xe8, 0xc9, 0x0e}
        -:  344:};
        -:  345:
        -:  346:// Diffusion Layer
        -:  347:void DL (const Byte *i, Byte *o)
        -:  348:{
        -:  349:	Byte T;
        -:  350:  
        -:  351:	T = i[ 3] ^ i[ 4] ^ i[ 9] ^ i[14];
        -:  352:	o[ 0] = i[ 6] ^ i[ 8] ^ i[13] ^ T;
        -:  353:	o[ 5] = i[ 1] ^ i[10] ^ i[15] ^ T;
        -:  354:	o[11] = i[ 2] ^ i[ 7] ^ i[12] ^ T;
        -:  355:	o[14] = i[ 0] ^ i[ 5] ^ i[11] ^ T;
        -:  356:	T = i[ 2] ^ i[ 5] ^ i[ 8] ^ i[15];
        -:  357:	o[ 1] = i[ 7] ^ i[ 9] ^ i[12] ^ T;
        -:  358:	o[ 4] = i[ 0] ^ i[11] ^ i[14] ^ T;
        -:  359:	o[10] = i[ 3] ^ i[ 6] ^ i[13] ^ T;
        -:  360:	o[15] = i[ 1] ^ i[ 4] ^ i[10] ^ T;
        -:  361:	T = i[ 1] ^ i[ 6] ^ i[11] ^ i[12];
        -:  362:	o[ 2] = i[ 4] ^ i[10] ^ i[15] ^ T;
        -:  363:	o[ 7] = i[ 3] ^ i[ 8] ^ i[13] ^ T;
        -:  364:	o[ 9] = i[ 0] ^ i[ 5] ^ i[14] ^ T;
        -:  365:	o[12] = i[ 2] ^ i[ 7] ^ i[ 9] ^ T;
        -:  366:	T = i[ 0] ^ i[ 7] ^ i[10] ^ i[13];
        -:  367:	o[ 3] = i[ 5] ^ i[11] ^ i[14] ^ T;
        -:  368:	o[ 6] = i[ 2] ^ i[ 9] ^ i[12] ^ T;
        -:  369:	o[ 8] = i[ 1] ^ i[ 4] ^ i[15] ^ T;
        -:  370:	o[13] = i[ 3] ^ i[ 6] ^ i[ 8] ^ T;
        -:  371:}
        -:  372:// Right-rotate 128 bit source string s by n bits and XOR it to target string t
        -:  373:void RotXOR (const Byte *s, int n, Byte *t)
        -:  374:{
        -:  375:	int i, q;
        -:  376:  
        -:  377:	q = n/8; n %= 8;
        -:  378:	for (i = 0; i < 16; i++) {
        -:  379:		t[(q+i) % 16] ^= (s[i] >> n);
        -:  380:		if (n != 0) t[(q+i+1) % 16] ^= (s[i] << (8-n));
        -:  381:	}
        -:  382:}
        -:  383:
        -:  384:void printBlock(Byte *b);
        -:  385:
        -:  386:// Encryption round key generation rountine
        -:  387:// w0 : master key, e : encryption round keys
        -:  388:int EncKeySetup(const Byte *w0, Byte *e, int keyBits) {
        -:  389:	int  i, R=(keyBits+256)/32, q;
        -:  390:	Byte t[16], w1[16], w2[16], w3[16];
        -:  391:  
        -:  392:	q = (keyBits - 128) / 64;
        -:  393:	for (i = 0; i < 16; i++) t[i] = S[     i  % 4][KRK[q][i   ] ^ w0[i]];
        -:  394:	DL (t, w1);
        -:  395:	if (R==14)
        -:  396:		for (i = 0; i <  8; i++) w1[i] ^= w0[16+i];
        -:  397:	else if (R==16)
        -:  398:		for (i = 0; i < 16; i++) w1[i] ^= w0[16+i];
        -:  399:  
        -:  400:	q = (q==2)? 0 : (q+1);
        -:  401:	for (i = 0; i < 16; i++) t[i] = S[(2 + i) % 4][KRK[q][i] ^ w1[i]];
        -:  402:	DL (t, w2);
        -:  403:	for (i = 0; i < 16; i++) w2[i] ^= w0[i];
        -:  404:  
        -:  405:	q = (q==2)? 0 : (q+1);
        -:  406:	for (i = 0; i < 16; i++) t[i] = S[     i  % 4][KRK[q][i] ^ w2[i]];
        -:  407:	DL (t, w3);
        -:  408:	for (i = 0; i < 16; i++) w3[i] ^= w1[i];
        -:  409:  
        -:  410:	for (i = 0; i < 16*(R+1); i++) e[i] = 0;
        -:  411:  
        -:  412:	RotXOR (w0, 0, e      ); RotXOR (w1,  19, e      );
        -:  413:	RotXOR (w1, 0, e +  16); RotXOR (w2,  19, e +  16);
        -:  414:	RotXOR (w2, 0, e +  32); RotXOR (w3,  19, e +  32);
        -:  415:	RotXOR (w3, 0, e +  48); RotXOR (w0,  19, e +  48);
        -:  416:	RotXOR (w0, 0, e +  64); RotXOR (w1,  31, e +  64);
        -:  417:	RotXOR (w1, 0, e +  80); RotXOR (w2,  31, e +  80);
        -:  418:	RotXOR (w2, 0, e +  96); RotXOR (w3,  31, e +  96);
        -:  419:	RotXOR (w3, 0, e + 112); RotXOR (w0,  31, e + 112);
        -:  420:	RotXOR (w0, 0, e + 128); RotXOR (w1,  67, e + 128);
        -:  421:	RotXOR (w1, 0, e + 144); RotXOR (w2,  67, e + 144);
        -:  422:	RotXOR (w2, 0, e + 160); RotXOR (w3,  67, e + 160);
        -:  423:	RotXOR (w3, 0, e + 176); RotXOR (w0,  67, e + 176);
        -:  424:	RotXOR (w0, 0, e + 192); RotXOR (w1,  97, e + 192);
        -:  425:	if (R > 12) {
        -:  426:		RotXOR (w1, 0, e + 208); RotXOR (w2,  97, e + 208);
        -:  427:		RotXOR (w2, 0, e + 224); RotXOR (w3,  97, e + 224);
        -:  428:	}
        -:  429:	if (R > 14) {
        -:  430:		RotXOR (w3, 0, e + 240); RotXOR (w0,  97, e + 240);
        -:  431:		RotXOR (w0, 0, e + 256); RotXOR (w1, 109, e + 256);
        -:  432:	}
        -:  433:	return R;
        -:  434:}
        -:  435:// Decryption round key generation rountine
        -:  436:// w0 : maskter key, d : decryption round keys
        -:  437:int DecKeySetup(const Byte *w0, Byte *d, int keyBits) {
        -:  438:	int  i, j, R;
        -:  439:	Byte t[16];
        -:  440:  
        -:  441:	R=EncKeySetup(w0, d, keyBits);
        -:  442:	for (j = 0; j < 16; j++){
        -:  443:		t[j] = d[j];
        -:  444:		d[j] = d[16*R + j];
        -:  445:		d[16*R + j] = t[j];
        -:  446:	}
        -:  447:	for (i = 1; i <= R/2; i++){
        -:  448:		DL (d + i*16, t);
        -:  449:		DL (d + (R-i)*16, d + i*16);
        -:  450:		for (j = 0; j < 16; j++) d[(R-i)*16 + j] = t[j];
        -:  451:	}
        -:  452:	return R;
        -:  453:}
        -:  454:// Encryption and decryption rountine
        -:  455:// p: plain text, e: round keys, c: ciphertext
        -:  456:void Crypt(const Byte *p, int R, const Byte *e, Byte *c)
        -:  457:{
        -:  458:	int i, j;
        -:  459:	Byte t[16];
        -:  460:  
        -:  461:	for (j = 0; j < 16; j++) c[j] = p[j];
        -:  462:	for (i = 0; i < R/2; i++)
        -:  463:	{
        -:  464:		for (j = 0; j < 16; j++) t[j] = S[     j  % 4][e[j] ^ c[j]];
        -:  465:		DL(t, c); e += 16;
        -:  466:		for (j = 0; j < 16; j++) t[j] = S[(2 + j) % 4][e[j] ^ c[j]];
        -:  467:		DL(t, c); e += 16;
        -:  468:	}
        -:  469:	DL(c, t);
        -:  470:	for (j = 0; j < 16; j++) c[j] = e[j] ^ t[j];
        -:  471:}
        -:  472:
        -:  473:void printBlockOfLength(Byte *b, int len) {
        -:  474:	int i;
        -:  475:  
        -:  476:	for (i=0; i<len; i++, b++) {
        -:  477:		printf("%02x", *b);
        -:  478:		if (i%4==3 && i<len-1) printf(" ");
        -:  479:	}
        -:  480:}
        -:  481:
        -:  482:void printBlock(Byte *b) {
        -:  483:  printBlockOfLength(b, 16);
        -:  484:}
        -:  485:
        -:  486:char func_ARIA (Byte *p) {
        -:  487:	Byte rk[16*17], c[16], mk[32];
        -:  488:	int i;
        -:  489:
        -:  490:	for (i=0; i<16; i++)
        -:  491:		mk[i]=i*0x11;
        -:  492:	for (i=16; i<24; i++)
        -:  493:		mk[i]=(i-16)*0x11;
        -:  494:  
        -:  495:	Crypt(p, EncKeySetup(mk, rk, 192), rk, c);
        -:  496:	printf("BEGIN testing basic encryption...\n");
        -:  497:	printf("Testing whether the encryption would come out correctly, \for 14-round ARIA.\n");
        -:  498:	printf("key      : "); printBlockOfLength(mk, 24); printf("\n");
        -:  499:	printf("plaintext: "); printBlock(p); printf("\n");
        -:  500:	printf("result is: "); printBlock(c); printf("\n");
        -:  501:	printf("END   testing basic encryption.\n\n");
        -:  502:
        -:  503:	return *p;
        -:  504:}
        -:  505:
        -:  506:
        -:  507:int main(int argc, char **argv)
        -:  508:{
        -:  509:	FILE *fp = NULL;
        -:  510:	
        -:  511:	fp = fopen("/home/joeun/testd/test200", "r");
        -:  512:	
        -:  513:	Byte p[16] = {"930926-12345671"};
        -:  514:
        -:  515:	func_ARIA(p);
        -:  516:
        -:  517:	return 0;
        -:  518:}
        -:  519:*/
        -:  520:
        -:  521:
